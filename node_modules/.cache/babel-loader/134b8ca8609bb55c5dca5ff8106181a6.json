{"ast":null,"code":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar vizion = require('vizion');\n\nvar cst = require('../constants.js');\n\nvar eachLimit = require('async/eachLimit');\n\nvar debug = require('debug')('pm2:worker');\n\nvar domain = require('domain');\n\nvar cronJob = require('cron').CronJob;\n\nvar vCheck = require('./VersionCheck.js');\n\nvar pkg = require('../package.json');\n\nmodule.exports = function (God) {\n  var timer = null;\n  God.CronJobs = new Map();\n  God.Worker = {};\n  God.Worker.is_running = false;\n\n  God.getCronID = function (pm_id) {\n    return `cron-${pm_id}`;\n  };\n\n  God.registerCron = function (pm2_env) {\n    if (!pm2_env || pm2_env.pm_id === undefined || !pm2_env.cron_restart || God.CronJobs.has(God.getCronID(pm2_env.pm_id))) return;\n    console.log('[PM2][WORKER] Registering a cron job on:', pm2_env.pm_id);\n    var job = new cronJob({\n      cronTime: pm2_env.cron_restart,\n      onTick: function () {\n        God.softReloadProcessId({\n          id: pm2_env.pm_id\n        }, function (err, data) {\n          if (err) console.error(err.stack || err);\n          return;\n        });\n      },\n      start: false\n    });\n    job.start();\n    God.CronJobs.set(God.getCronID(pm2_env.pm_id), job);\n  };\n  /**\n   * Deletes the cron job on deletion of process\n   */\n\n\n  God.deleteCron = function (id) {\n    if (typeof id !== 'undefined' && God.CronJobs.has(God.getCronID(id)) === false) return;\n    console.log('[PM2] Deregistering a cron job on:', id);\n    var job = God.CronJobs.get(God.getCronID(id));\n    job.stop();\n    God.CronJobs.delete(God.getCronID(id));\n  };\n\n  var _getProcessById = function (pm_id) {\n    var proc = God.clusters_db[pm_id];\n    return proc ? proc : null;\n  };\n\n  var maxMemoryRestart = function (proc_key, cb) {\n    var proc = _getProcessById(proc_key.pm2_env.pm_id);\n\n    if (!(proc && proc.pm2_env && proc_key.monit)) return cb();\n\n    if (proc_key.monit.memory !== undefined && proc.pm2_env.max_memory_restart !== undefined && proc.pm2_env.max_memory_restart < proc_key.monit.memory && proc.pm2_env.axm_options && proc.pm2_env.axm_options.pid === undefined) {\n      console.log('[PM2][WORKER] Process %s restarted because it exceeds --max-memory-restart value (current_memory=%s max_memory_limit=%s [octets])', proc.pm2_env.pm_id, proc_key.monit.memory, proc.pm2_env.max_memory_restart);\n      God.softReloadProcessId({\n        id: proc.pm2_env.pm_id\n      }, function (err, data) {\n        if (err) console.error(err.stack || err);\n        return cb();\n      });\n    } else {\n      return cb();\n    }\n  }; // Deprecated\n\n\n  var versioningRefresh = function (proc_key, cb) {\n    var proc = _getProcessById(proc_key.pm2_env.pm_id);\n\n    if (!(proc && proc.pm2_env && proc.pm2_env.vizion !== false && proc.pm2_env.vizion != \"false\" && proc.pm2_env.versioning && proc.pm2_env.versioning.repo_path)) {\n      return cb();\n    }\n\n    if (proc.pm2_env.vizion_running === true) {\n      debug('Vizion is already running for proc id: %d, skipping this round', proc.pm2_env.pm_id);\n      return cb();\n    }\n\n    proc.pm2_env.vizion_running = true;\n    var repo_path = proc.pm2_env.versioning.repo_path;\n    vizion.analyze({\n      folder: proc.pm2_env.versioning.repo_path\n    }, function (err, meta) {\n      if (err != null) return cb();\n      proc = _getProcessById(proc_key.pm2_env.pm_id);\n\n      if (!(proc && proc.pm2_env && proc.pm2_env.versioning && proc.pm2_env.versioning.repo_path)) {\n        console.error('Proc not defined anymore or versioning unknown');\n        return cb();\n      }\n\n      proc.pm2_env.vizion_running = false;\n      meta.repo_path = repo_path;\n      proc.pm2_env.versioning = meta;\n      debug('[PM2][WORKER] %s parsed for versioning', proc.pm2_env.name);\n      return cb();\n    });\n  };\n\n  var tasks = function () {\n    if (God.Worker.is_running === true) {\n      debug('[PM2][WORKER] Worker is already running, skipping this round');\n      return false;\n    }\n\n    God.Worker.is_running = true;\n    God.getMonitorData(null, function (err, data) {\n      if (err || !data || typeof data !== 'object') {\n        God.Worker.is_running = false;\n        return console.error(err);\n      }\n\n      eachLimit(data, 1, function (proc, next) {\n        if (!proc || !proc.pm2_env || proc.pm2_env.pm_id === undefined) return next();\n        debug('[PM2][WORKER] Processing proc id:', proc.pm2_env.pm_id); // Reset restart delay if application has an uptime of more > 30secs\n\n        if (proc.pm2_env.exp_backoff_restart_delay !== undefined && proc.pm2_env.prev_restart_delay && proc.pm2_env.prev_restart_delay > 0) {\n          var app_uptime = Date.now() - proc.pm2_env.pm_uptime;\n\n          if (app_uptime > cst.EXP_BACKOFF_RESET_TIMER) {\n            var ref_proc = _getProcessById(proc.pm2_env.pm_id);\n\n            ref_proc.pm2_env.prev_restart_delay = 0;\n            console.log(`[PM2][WORKER] Reset the restart delay, as app ${proc.name} has been up for more than ${cst.EXP_BACKOFF_RESET_TIMER}ms`);\n          }\n        } // Check if application has reached memory threshold\n\n\n        maxMemoryRestart(proc, function () {\n          return next();\n        });\n      }, function (err) {\n        God.Worker.is_running = false;\n        debug('[PM2][WORKER] My job here is done, next job in %d seconds', parseInt(cst.WORKER_INTERVAL / 1000));\n      });\n    });\n  };\n\n  var wrappedTasks = function () {\n    var d = domain.create();\n    d.once('error', function (err) {\n      console.error('[PM2][WORKER] Error caught by domain:\\n' + (err.stack || err));\n      God.Worker.is_running = false;\n    });\n    d.run(function () {\n      tasks();\n    });\n  };\n\n  God.Worker.start = function () {\n    timer = setInterval(wrappedTasks, cst.WORKER_INTERVAL);\n    setInterval(() => {\n      vCheck({\n        state: 'check',\n        version: pkg.version\n      });\n    }, 1000 * 60 * 60 * 24);\n  };\n\n  God.Worker.stop = function () {\n    if (timer !== null) clearInterval(timer);\n  };\n};","map":{"version":3,"sources":["/Users/samianki/node_modules/pm2/lib/Worker.js"],"names":["vizion","require","cst","eachLimit","debug","domain","cronJob","CronJob","vCheck","pkg","module","exports","God","timer","CronJobs","Map","Worker","is_running","getCronID","pm_id","registerCron","pm2_env","undefined","cron_restart","has","console","log","job","cronTime","onTick","softReloadProcessId","id","err","data","error","stack","start","set","deleteCron","get","stop","delete","_getProcessById","proc","clusters_db","maxMemoryRestart","proc_key","cb","monit","memory","max_memory_restart","axm_options","pid","versioningRefresh","versioning","repo_path","vizion_running","analyze","folder","meta","name","tasks","getMonitorData","next","exp_backoff_restart_delay","prev_restart_delay","app_uptime","Date","now","pm_uptime","EXP_BACKOFF_RESET_TIMER","ref_proc","parseInt","WORKER_INTERVAL","wrappedTasks","d","create","once","run","setInterval","state","version","clearInterval"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar vizion    = require('vizion');\nvar cst       = require('../constants.js');\nvar eachLimit = require('async/eachLimit');\nvar debug     = require('debug')('pm2:worker');\nvar domain    = require('domain');\nvar cronJob = require('cron').CronJob\nvar vCheck = require('./VersionCheck.js')\nvar pkg = require('../package.json')\n\nmodule.exports = function(God) {\n  var timer = null;\n\n  God.CronJobs = new Map();\n  God.Worker = {};\n  God.Worker.is_running = false;\n\n  God.getCronID = function(pm_id) {\n    return `cron-${pm_id}`\n  }\n\n  God.registerCron = function(pm2_env) {\n    if (!pm2_env ||\n        pm2_env.pm_id === undefined ||\n        !pm2_env.cron_restart ||\n        God.CronJobs.has(God.getCronID(pm2_env.pm_id)))\n      return;\n\n    console.log('[PM2][WORKER] Registering a cron job on:', pm2_env.pm_id);\n\n    var job = new cronJob({\n      cronTime: pm2_env.cron_restart,\n      onTick: function() {\n        God.softReloadProcessId({id: pm2_env.pm_id}, function(err, data) {\n          if (err)\n            console.error(err.stack || err);\n          return;\n        });\n      },\n      start: false\n    });\n\n    job.start();\n    God.CronJobs.set(God.getCronID(pm2_env.pm_id), job);\n  }\n\n\n  /**\n   * Deletes the cron job on deletion of process\n   */\n  God.deleteCron = function(id) {\n    if (typeof(id) !== 'undefined' && God.CronJobs.has(God.getCronID(id)) === false)\n      return;\n    console.log('[PM2] Deregistering a cron job on:', id);\n    var job = God.CronJobs.get(God.getCronID(id));\n    job.stop();\n    God.CronJobs.delete(God.getCronID(id));\n  };\n\n  var _getProcessById = function(pm_id) {\n    var proc = God.clusters_db[pm_id];\n    return proc ? proc : null;\n  };\n\n\n  var maxMemoryRestart = function(proc_key, cb) {\n    var proc = _getProcessById(proc_key.pm2_env.pm_id);\n\n    if (!(proc &&\n          proc.pm2_env &&\n          proc_key.monit))\n      return cb();\n\n    if (proc_key.monit.memory !== undefined &&\n        proc.pm2_env.max_memory_restart !== undefined &&\n        proc.pm2_env.max_memory_restart < proc_key.monit.memory &&\n        proc.pm2_env.axm_options &&\n        proc.pm2_env.axm_options.pid === undefined) {\n      console.log('[PM2][WORKER] Process %s restarted because it exceeds --max-memory-restart value (current_memory=%s max_memory_limit=%s [octets])', proc.pm2_env.pm_id, proc_key.monit.memory, proc.pm2_env.max_memory_restart);\n      God.softReloadProcessId({\n        id : proc.pm2_env.pm_id\n      }, function(err, data) {\n        if (err)\n          console.error(err.stack || err);\n        return cb();\n      });\n    }\n    else {\n      return cb();\n    }\n  };\n\n  // Deprecated\n  var versioningRefresh = function(proc_key, cb) {\n    var proc = _getProcessById(proc_key.pm2_env.pm_id);\n    if (!(proc &&\n          proc.pm2_env &&\n          (proc.pm2_env.vizion !== false && proc.pm2_env.vizion != \"false\") &&\n          proc.pm2_env.versioning &&\n          proc.pm2_env.versioning.repo_path)) {\n      return cb();\n    }\n\n    if (proc.pm2_env.vizion_running === true)\n    {\n      debug('Vizion is already running for proc id: %d, skipping this round', proc.pm2_env.pm_id);\n      return cb();\n    }\n\n    proc.pm2_env.vizion_running = true;\n    var repo_path = proc.pm2_env.versioning.repo_path;\n\n    vizion.analyze({\n      folder: proc.pm2_env.versioning.repo_path\n    },\n    function(err, meta) {\n      if (err != null)\n        return cb();\n\n      proc = _getProcessById(proc_key.pm2_env.pm_id);\n\n      if (!(proc &&\n            proc.pm2_env &&\n            proc.pm2_env.versioning &&\n            proc.pm2_env.versioning.repo_path)) {\n        console.error('Proc not defined anymore or versioning unknown');\n        return cb();\n      }\n\n      proc.pm2_env.vizion_running = false;\n      meta.repo_path = repo_path;\n      proc.pm2_env.versioning = meta;\n      debug('[PM2][WORKER] %s parsed for versioning', proc.pm2_env.name);\n      return cb();\n    });\n  };\n\n  var tasks = function() {\n    if (God.Worker.is_running === true) {\n      debug('[PM2][WORKER] Worker is already running, skipping this round');\n      return false;\n    }\n    God.Worker.is_running = true;\n\n    God.getMonitorData(null, function(err, data) {\n      if (err || !data || typeof(data) !== 'object') {\n        God.Worker.is_running = false;\n        return console.error(err);\n      }\n\n      eachLimit(data, 1, function(proc, next) {\n        if (!proc || !proc.pm2_env || proc.pm2_env.pm_id === undefined)\n          return next();\n\n        debug('[PM2][WORKER] Processing proc id:', proc.pm2_env.pm_id);\n\n        // Reset restart delay if application has an uptime of more > 30secs\n        if (proc.pm2_env.exp_backoff_restart_delay !== undefined &&\n            proc.pm2_env.prev_restart_delay && proc.pm2_env.prev_restart_delay > 0) {\n          var app_uptime = Date.now() - proc.pm2_env.pm_uptime\n          if (app_uptime > cst.EXP_BACKOFF_RESET_TIMER) {\n            var ref_proc = _getProcessById(proc.pm2_env.pm_id);\n            ref_proc.pm2_env.prev_restart_delay = 0\n            console.log(`[PM2][WORKER] Reset the restart delay, as app ${proc.name} has been up for more than ${cst.EXP_BACKOFF_RESET_TIMER}ms`)\n          }\n        }\n\n        // Check if application has reached memory threshold\n        maxMemoryRestart(proc, function() {\n          return next();\n        });\n      }, function(err) {\n        God.Worker.is_running = false;\n        debug('[PM2][WORKER] My job here is done, next job in %d seconds', parseInt(cst.WORKER_INTERVAL / 1000));\n      });\n    });\n  };\n\n  var wrappedTasks = function() {\n    var d = domain.create();\n\n    d.once('error', function(err) {\n      console.error('[PM2][WORKER] Error caught by domain:\\n' + (err.stack || err));\n      God.Worker.is_running = false;\n    });\n\n    d.run(function() {\n      tasks();\n    });\n  };\n\n\n  God.Worker.start = function() {\n    timer = setInterval(wrappedTasks, cst.WORKER_INTERVAL);\n\n    setInterval(() => {\n      vCheck({\n        state: 'check',\n        version: pkg.version\n      })\n    }, 1000 * 60 * 60 * 24)\n  };\n\n  God.Worker.stop = function() {\n    if (timer !== null)\n      clearInterval(timer);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}