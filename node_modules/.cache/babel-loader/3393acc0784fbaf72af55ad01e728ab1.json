{"ast":null,"code":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar util = require('util');\n/**\n * Validator of configured file / commander options.\n */\n\n\nvar Config = module.exports = {\n  _errMsgs: {\n    'require': '\"%s\" is required',\n    'type': 'Expect \"%s\" to be a typeof %s, but now is %s',\n    'regex': 'Verify \"%s\" with regex failed, %s',\n    'max': 'The maximum of \"%s\" is %s, but now is %s',\n    'min': 'The minimum of \"%s\" is %s, but now is %s'\n  },\n\n  /**\n   * Schema definition.\n   * @returns {exports|*}\n   */\n  get schema() {\n    // Cache.\n    if (this._schema) {\n      return this._schema;\n    } // Render aliases.\n\n\n    this._schema = require('../API/schema');\n\n    for (var k in this._schema) {\n      if (k.indexOf('\\\\') > 0) {\n        continue;\n      }\n\n      var aliases = [k.split('_').map(function (n, i) {\n        if (i != 0 && n && n.length > 1) {\n          return n[0].toUpperCase() + n.slice(1);\n        }\n\n        return n;\n      }).join('')];\n\n      if (this._schema[k].alias && Array.isArray(this._schema[k].alias)) {\n        // If multiple aliases, merge\n        this._schema[k].alias.forEach(function (alias) {\n          aliases.splice(0, 0, alias);\n        });\n      } else if (this._schema[k].alias) aliases.splice(0, 0, this._schema[k].alias);\n\n      this._schema[k].alias = aliases;\n    }\n\n    return this._schema;\n  }\n\n};\n/**\n * Filter / Alias options\n */\n\nConfig.filterOptions = function (cmd) {\n  var conf = {};\n  var schema = this.schema;\n\n  for (var key in schema) {\n    var aliases = schema[key].alias;\n    aliases && aliases.forEach(function (alias) {\n      if (typeof cmd[alias] !== 'undefined') {\n        conf[key] || (conf[key] = cmd[alias]);\n      }\n    });\n  }\n\n  return conf;\n};\n/**\n * Verify JSON configurations.\n * @param {Object} json\n * @returns {{errors: Array, config: {}}}\n */\n\n\nConfig.validateJSON = function (json) {\n  // clone config\n  var conf = util._extend({}, json),\n      res = {};\n\n  this._errors = [];\n  var regexKeys = {},\n      defines = this.schema;\n\n  for (var sk in defines) {\n    // Pick up RegExp keys.\n    if (sk.indexOf('\\\\') >= 0) {\n      regexKeys[sk] = false;\n      continue;\n    }\n\n    var aliases = defines[sk].alias;\n    aliases && aliases.forEach(function (alias) {\n      conf[sk] || (conf[sk] = json[alias]);\n    });\n    var val = conf[sk];\n    delete conf[sk]; // Validate key-value pairs.\n\n    if (val === undefined || val === null || (val = this._valid(sk, val)) === null) {\n      // If value is not defined\n      // Set default value (via schema.json)\n      if (typeof defines[sk].default !== 'undefined') res[sk] = defines[sk].default;\n      continue;\n    } //console.log(sk, val, val === null, val === undefined);\n\n\n    res[sk] = val;\n  } // Validate RegExp values.\n\n\n  var hasRegexKey = false;\n\n  for (var k in regexKeys) {\n    hasRegexKey = true;\n    regexKeys[k] = new RegExp(k);\n  }\n\n  if (hasRegexKey) {\n    for (var k in conf) {\n      for (var rk in regexKeys) {\n        if (regexKeys[rk].test(k)) if (this._valid(k, conf[k], defines[rk])) {\n          res[k] = conf[k];\n          delete conf[k];\n        }\n      }\n    }\n  }\n\n  return {\n    errors: this._errors,\n    config: res\n  };\n};\n/**\n * Validate key-value pairs by specific schema\n * @param {String} key\n * @param {Mixed} value\n * @param {Object} sch\n * @returns {*}\n * @private\n */\n\n\nConfig._valid = function (key, value, sch) {\n  var sch = sch || this.schema[key],\n      scht = typeof sch.type == 'string' ? [sch.type] : sch.type; // Required value.\n\n  var undef = typeof value == 'undefined';\n\n  if (this._error(sch.require && undef, 'require', key)) {\n    return null;\n  } // If undefined, make a break.\n\n\n  if (undef) {\n    return null;\n  } // Wrap schema types.\n\n\n  scht = scht.map(function (t) {\n    return '[object ' + t[0].toUpperCase() + t.slice(1) + ']';\n  }); // Typeof value.\n\n  var type = Object.prototype.toString.call(value),\n      nt = '[object Number]'; // Auto parse Number\n\n  if (type != '[object Boolean]' && scht.indexOf(nt) >= 0 && !isNaN(value)) {\n    value = parseFloat(value);\n    type = nt;\n  } // Verify types.\n\n\n  if (this._error(!~scht.indexOf(type), 'type', key, scht.join(' / '), type)) {\n    return null;\n  } // Verify RegExp if exists.\n\n\n  if (this._error(type == '[object String]' && sch.regex && !new RegExp(sch.regex).test(value), 'regex', key, sch.desc || 'should match ' + sch.regex)) {\n    return null;\n  } // Verify maximum / minimum of Number value.\n\n\n  if (type == '[object Number]') {\n    if (this._error(typeof sch.max != 'undefined' && value > sch.max, 'max', key, sch.max, value)) {\n      return null;\n    }\n\n    if (this._error(typeof sch.min != 'undefined' && value < sch.min, 'min', key, sch.min, value)) {\n      return null;\n    }\n  } // If first type is Array, but current is String, try to split them.\n\n\n  if (scht.length > 1 && type != scht[0] && type == '[object String]') {\n    if (scht[0] == '[object Array]') {\n      // unfortunately, js does not support lookahead RegExp (/(?<!\\\\)\\s+/) now (until next ver).\n      value = value.split(/([\\w\\-]+\\=\"[^\"]*\")|([\\w\\-]+\\='[^']*')|\"([^\"]*)\"|'([^']*)'|\\s/).filter(function (v) {\n        return v && v.trim();\n      });\n    }\n  } // Custom types: sbyte && stime.\n\n\n  if (sch.ext_type && type == '[object String]' && value.length >= 2) {\n    var seed = {\n      'sbyte': {\n        'G': 1024 * 1024 * 1024,\n        'M': 1024 * 1024,\n        'K': 1024\n      },\n      'stime': {\n        'h': 60 * 60 * 1000,\n        'm': 60 * 1000,\n        's': 1000\n      }\n    }[sch.ext_type];\n\n    if (seed) {\n      value = parseFloat(value.slice(0, -1)) * seed[value.slice(-1)];\n    }\n  }\n\n  return value;\n};\n/**\n * Wrap errors.\n * @param {Boolean} possible A value indicates whether it is an error or not.\n * @param {String} type\n * @returns {*}\n * @private\n */\n\n\nConfig._error = function (possible, type) {\n  if (possible) {\n    var args = Array.prototype.slice.call(arguments);\n    args.splice(0, 2, this._errMsgs[type]);\n    this._errors && this._errors.push(util.format.apply(null, args));\n  }\n\n  return possible;\n};","map":{"version":3,"sources":["/Users/samianki/node_modules/pm2/lib/tools/Config.js"],"names":["util","require","Config","module","exports","_errMsgs","schema","_schema","k","indexOf","aliases","split","map","n","i","length","toUpperCase","slice","join","alias","Array","isArray","forEach","splice","filterOptions","cmd","conf","key","validateJSON","json","_extend","res","_errors","regexKeys","defines","sk","val","undefined","_valid","default","hasRegexKey","RegExp","rk","test","errors","config","value","sch","scht","type","undef","_error","t","Object","prototype","toString","call","nt","isNaN","parseFloat","regex","desc","max","min","filter","v","trim","ext_type","seed","possible","args","arguments","push","format","apply"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar util    = require('util');\n\n/**\n * Validator of configured file / commander options.\n */\nvar Config = module.exports = {\n  _errMsgs: {\n    'require': '\"%s\" is required',\n    'type'   : 'Expect \"%s\" to be a typeof %s, but now is %s',\n    'regex'  : 'Verify \"%s\" with regex failed, %s',\n    'max'    : 'The maximum of \"%s\" is %s, but now is %s',\n    'min'    : 'The minimum of \"%s\" is %s, but now is %s'\n  },\n  /**\n   * Schema definition.\n   * @returns {exports|*}\n   */\n  get schema(){\n    // Cache.\n    if (this._schema) {\n      return this._schema;\n    }\n    // Render aliases.\n    this._schema = require('../API/schema');\n    for (var k in this._schema) {\n      if (k.indexOf('\\\\') > 0) {\n        continue;\n      }\n      var aliases = [\n        k.split('_').map(function(n, i){\n          if (i != 0 && n && n.length > 1) {\n            return n[0].toUpperCase() + n.slice(1);\n          }\n          return n;\n        }).join('')\n      ];\n\n      if (this._schema[k].alias && Array.isArray(this._schema[k].alias)) {\n        // If multiple aliases, merge\n        this._schema[k].alias.forEach(function(alias) {\n          aliases.splice(0, 0, alias);\n        });\n      }\n      else if (this._schema[k].alias)\n        aliases.splice(0, 0, this._schema[k].alias);\n\n      this._schema[k].alias = aliases;\n    }\n    return this._schema;\n  }\n};\n\n/**\n * Filter / Alias options\n */\nConfig.filterOptions = function(cmd) {\n  var conf = {};\n  var schema = this.schema;\n\n  for (var key in schema) {\n    var aliases = schema[key].alias;\n    aliases && aliases.forEach(function(alias){\n      if (typeof(cmd[alias]) !== 'undefined') {\n        conf[key] || (conf[key] = cmd[alias]);\n      }\n    });\n  }\n\n  return conf;\n};\n\n/**\n * Verify JSON configurations.\n * @param {Object} json\n * @returns {{errors: Array, config: {}}}\n */\nConfig.validateJSON = function(json){\n  // clone config\n  var conf = util._extend({}, json),\n      res = {};\n  this._errors = [];\n\n  var regexKeys = {}, defines = this.schema;\n\n  for (var sk in defines) {\n    // Pick up RegExp keys.\n    if (sk.indexOf('\\\\') >= 0) {\n      regexKeys[sk] = false;\n      continue;\n    }\n\n    var aliases = defines[sk].alias;\n\n    aliases && aliases.forEach(function(alias){\n      conf[sk] || (conf[sk] = json[alias]);\n    })\n\n    var val = conf[sk];\n    delete conf[sk];\n\n    // Validate key-value pairs.\n    if (val === undefined ||\n        val === null ||\n        ((val = this._valid(sk, val)) === null)) {\n\n      // If value is not defined\n      // Set default value (via schema.json)\n      if (typeof(defines[sk].default) !== 'undefined')\n        res[sk] = defines[sk].default;\n      continue;\n    }\n    //console.log(sk, val, val === null, val === undefined);\n    res[sk] = val;\n  }\n\n  // Validate RegExp values.\n  var hasRegexKey = false;\n  for (var k in regexKeys) {\n    hasRegexKey = true;\n    regexKeys[k] = new RegExp(k);\n  }\n  if (hasRegexKey) {\n    for (var k in conf) {\n      for (var rk in regexKeys) {\n        if (regexKeys[rk].test(k))\n          if (this._valid(k, conf[k], defines[rk])) {\n            res[k] = conf[k];\n            delete conf[k];\n          }\n      }\n    }\n  }\n\n  return {errors: this._errors, config: res};\n};\n\n/**\n * Validate key-value pairs by specific schema\n * @param {String} key\n * @param {Mixed} value\n * @param {Object} sch\n * @returns {*}\n * @private\n */\nConfig._valid = function(key, value, sch){\n  var sch = sch || this.schema[key],\n      scht = typeof sch.type == 'string' ? [sch.type] : sch.type;\n\n  // Required value.\n  var undef = typeof value == 'undefined';\n  if(this._error(sch.require && undef, 'require', key)){\n    return null;\n  }\n\n  // If undefined, make a break.\n  if (undef) {\n    return null;\n  }\n\n  // Wrap schema types.\n  scht = scht.map(function(t){\n    return '[object ' + t[0].toUpperCase() + t.slice(1) + ']'\n  });\n\n  // Typeof value.\n  var type = Object.prototype.toString.call(value), nt = '[object Number]';\n\n  // Auto parse Number\n  if (type != '[object Boolean]' && scht.indexOf(nt) >= 0 && !isNaN(value)) {\n    value = parseFloat(value);\n    type = nt;\n  }\n\n  // Verify types.\n  if (this._error(!~scht.indexOf(type), 'type', key, scht.join(' / '), type)) {\n    return null;\n  }\n\n  // Verify RegExp if exists.\n  if (this._error(type == '[object String]' && sch.regex && !(new RegExp(sch.regex)).test(value),\n      'regex', key, sch.desc || ('should match ' + sch.regex))) {\n    return null;\n  }\n\n  // Verify maximum / minimum of Number value.\n  if (type == '[object Number]') {\n    if (this._error(typeof sch.max != 'undefined' && value > sch.max, 'max', key, sch.max, value)) {\n      return null;\n    }\n    if (this._error(typeof sch.min != 'undefined' && value < sch.min, 'min', key, sch.min, value)) {\n      return null;\n    }\n  }\n\n  // If first type is Array, but current is String, try to split them.\n  if(scht.length > 1 && type != scht[0] && type == '[object String]'){\n    if(scht[0] == '[object Array]') {\n      // unfortunately, js does not support lookahead RegExp (/(?<!\\\\)\\s+/) now (until next ver).\n      value = value.split(/([\\w\\-]+\\=\"[^\"]*\")|([\\w\\-]+\\='[^']*')|\"([^\"]*)\"|'([^']*)'|\\s/)\n        .filter(function(v){\n          return v && v.trim();\n        });\n    }\n  }\n\n  // Custom types: sbyte && stime.\n  if(sch.ext_type && type == '[object String]' && value.length >= 2) {\n    var seed = {\n      'sbyte': {\n        'G': 1024 * 1024 * 1024,\n        'M': 1024 * 1024,\n        'K': 1024\n      },\n      'stime': {\n        'h': 60 * 60 * 1000,\n        'm': 60 * 1000,\n        's': 1000\n      }\n    }[sch.ext_type];\n\n    if(seed){\n      value = parseFloat(value.slice(0, -1)) * (seed[value.slice(-1)]);\n    }\n  }\n  return value;\n};\n\n/**\n * Wrap errors.\n * @param {Boolean} possible A value indicates whether it is an error or not.\n * @param {String} type\n * @returns {*}\n * @private\n */\nConfig._error = function(possible, type){\n  if (possible) {\n    var args = Array.prototype.slice.call(arguments);\n    args.splice(0, 2, this._errMsgs[type]);\n    this._errors && this._errors.push(util.format.apply(null, args));\n  }\n  return possible;\n}\n"]},"metadata":{},"sourceType":"script"}