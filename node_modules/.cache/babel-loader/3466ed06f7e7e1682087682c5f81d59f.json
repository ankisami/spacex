{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar Emitter = require('events').EventEmitter;\n\nvar Configurable = require('../configurable');\n\nvar debug = require('debug')('axon:sock');\n\nvar Message = require('amp-message');\n\nvar Parser = require('amp').Stream;\n\nvar url = require('url');\n\nvar net = require('net');\n\nvar fs = require('fs');\n/**\n * Errors to ignore.\n */\n\n\nvar ignore = ['ECONNREFUSED', 'ECONNRESET', 'ETIMEDOUT', 'EHOSTUNREACH', 'ENETUNREACH', 'ENETDOWN', 'EPIPE', 'ENOENT'];\n/**\n * Expose `Socket`.\n */\n\nmodule.exports = Socket;\n/**\n * Initialize a new `Socket`.\n *\n * A \"Socket\" encapsulates the ability of being\n * the \"client\" or the \"server\" depending on\n * whether `connect()` or `bind()` was called.\n *\n * @api private\n */\n\nfunction Socket() {\n  var self = this;\n  this.opts = {};\n  this.server = null;\n  this.socks = [];\n  this.settings = {};\n  this.set('hwm', Infinity);\n  this.set('identity', String(process.pid));\n  this.set('retry timeout', 100);\n  this.set('retry max timeout', 5000);\n}\n/**\n * Inherit from `Emitter.prototype`.\n */\n\n\nSocket.prototype.__proto__ = Emitter.prototype;\n/**\n * Make it configurable `.set()` etc.\n */\n\nConfigurable(Socket.prototype);\n/**\n * Use the given `plugin`.\n *\n * @param {Function} plugin\n * @api private\n */\n\nSocket.prototype.use = function (plugin) {\n  plugin(this);\n  return this;\n};\n/**\n * Creates a new `Message` and write the `args`.\n *\n * @param {Array} args\n * @return {Buffer}\n * @api private\n */\n\n\nSocket.prototype.pack = function (args) {\n  var msg = new Message(args);\n  return msg.toBuffer();\n};\n/**\n * Close all open underlying sockets.\n *\n * @api private\n */\n\n\nSocket.prototype.closeSockets = function () {\n  debug('closing %d connections', this.socks.length);\n  this.socks.forEach(function (sock) {\n    sock.destroy();\n  });\n};\n/**\n * Close the socket.\n *\n * Delegates to the server or clients\n * based on the socket `type`.\n *\n * @param {Function} [fn]\n * @api public\n */\n\n\nSocket.prototype.close = function (fn) {\n  debug('closing');\n  this.closing = true;\n  this.closeSockets();\n  if (this.server) this.closeServer(fn);\n};\n/**\n * Close the server.\n *\n * @param {Function} [fn]\n * @api public\n */\n\n\nSocket.prototype.closeServer = function (fn) {\n  debug('closing server');\n  this.server.on('close', this.emit.bind(this, 'close'));\n  this.server.close();\n  fn && fn();\n};\n/**\n * Return the server address.\n *\n * @return {Object}\n * @api public\n */\n\n\nSocket.prototype.address = function () {\n  if (!this.server) return;\n  var addr = this.server.address();\n  addr.string = 'tcp://' + addr.address + ':' + addr.port;\n  return addr;\n};\n/**\n * Remove `sock`.\n *\n * @param {Socket} sock\n * @api private\n */\n\n\nSocket.prototype.removeSocket = function (sock) {\n  var i = this.socks.indexOf(sock);\n  if (!~i) return;\n  debug('remove socket %d', i);\n  this.socks.splice(i, 1);\n};\n/**\n * Add `sock`.\n *\n * @param {Socket} sock\n * @api private\n */\n\n\nSocket.prototype.addSocket = function (sock) {\n  var parser = new Parser();\n  var i = this.socks.push(sock) - 1;\n  debug('add socket %d', i);\n  sock.pipe(parser);\n  parser.on('data', this.onmessage(sock));\n};\n/**\n * Handle `sock` errors.\n *\n * Emits:\n *\n *  - `error` (err) when the error is not ignored\n *  - `ignored error` (err) when the error is ignored\n *  - `socket error` (err) regardless of ignoring\n *\n * @param {Socket} sock\n * @api private\n */\n\n\nSocket.prototype.handleErrors = function (sock) {\n  var self = this;\n  sock.on('error', function (err) {\n    debug('error %s', err.code || err.message);\n    self.emit('socket error', err);\n    self.removeSocket(sock);\n    if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n    debug('ignored %s', err.code);\n    self.emit('ignored error', err);\n  });\n};\n/**\n * Handles framed messages emitted from the parser, by\n * default it will go ahead and emit the \"message\" events on\n * the socket. However, if the \"higher level\" socket needs\n * to hook into the messages before they are emitted, it\n * should override this method and take care of everything\n * it self, including emitted the \"message\" event.\n *\n * @param {net.Socket} sock\n * @return {Function} closure(msg, mulitpart)\n * @api private\n */\n\n\nSocket.prototype.onmessage = function (sock) {\n  var self = this;\n  return function (buf) {\n    var msg = new Message(buf);\n    self.emit.apply(self, ['message'].concat(msg.args), sock);\n  };\n};\n/**\n * Connect to `port` at `host` and invoke `fn()`.\n *\n * Defaults `host` to localhost.\n *\n * TODO: needs big cleanup\n *\n * @param {Number|String} port\n * @param {String} host\n * @param {Function} fn\n * @return {Socket}\n * @api public\n */\n\n\nSocket.prototype.connect = function (port, host, fn) {\n  var self = this;\n  if ('server' == this.type) throw new Error('cannot connect() after bind()');\n  if ('function' == typeof host) fn = host, host = undefined;\n\n  if ('string' == typeof port) {\n    port = url.parse(port);\n\n    if (port.pathname) {\n      fn = host;\n      host = null;\n      fn = undefined;\n      port = port.pathname;\n    } else {\n      host = port.hostname || '0.0.0.0';\n      port = parseInt(port.port, 10);\n    }\n  } else {\n    host = host || '0.0.0.0';\n  }\n\n  var max = self.get('retry max timeout');\n  var sock = new net.Socket();\n  sock.setNoDelay();\n  this.type = 'client';\n  port = port;\n  this.handleErrors(sock);\n  sock.on('close', function () {\n    self.connected = false;\n    self.removeSocket(sock);\n    if (self.closing) return self.emit('close');\n    var retry = self.retry || self.get('retry timeout');\n    if (retry === 0) return self.emit('close');\n    setTimeout(function () {\n      debug('attempting reconnect');\n      self.emit('reconnect attempt');\n      sock.destroy();\n      self.connect(port, host);\n      self.retry = Math.round(Math.min(max, retry * 1.5));\n    }, retry);\n  });\n  sock.on('connect', function () {\n    debug('connect');\n    self.connected = true;\n    self.addSocket(sock);\n    self.retry = self.get('retry timeout');\n    self.emit('connect');\n    fn && fn();\n  });\n  debug('connect attempt %s:%s', host, port);\n  sock.connect(port, host);\n  return this;\n};\n/**\n * Handle connection.\n *\n * @param {Socket} sock\n * @api private\n */\n\n\nSocket.prototype.onconnect = function (sock) {\n  var self = this;\n  var addr = null;\n  if (sock.remoteAddress && sock.remotePort) addr = sock.remoteAddress + ':' + sock.remotePort;else if (sock.server && sock.server._pipeName) addr = sock.server._pipeName;\n  debug('accept %s', addr);\n  this.addSocket(sock);\n  this.handleErrors(sock);\n  this.emit('connect', sock);\n  sock.on('close', function () {\n    debug('disconnect %s', addr);\n    self.emit('disconnect', sock);\n    self.removeSocket(sock);\n  });\n};\n/**\n * Bind to `port` at `host` and invoke `fn()`.\n *\n * Defaults `host` to INADDR_ANY.\n *\n * Emits:\n *\n *  - `connection` when a client connects\n *  - `disconnect` when a client disconnects\n *  - `bind` when bound and listening\n *\n * @param {Number|String} port\n * @param {Function} fn\n * @return {Socket}\n * @api public\n */\n\n\nSocket.prototype.bind = function (port, host, fn) {\n  var self = this;\n  if ('client' == this.type) throw new Error('cannot bind() after connect()');\n  if ('function' == typeof host) fn = host, host = undefined;\n  var unixSocket = false;\n\n  if ('string' == typeof port) {\n    port = url.parse(port);\n\n    if (port.pathname) {\n      fn = host;\n      host = null;\n      port = port.pathname;\n      unixSocket = true;\n    } else {\n      host = port.hostname || '0.0.0.0';\n      port = parseInt(port.port, 10);\n    }\n  } else {\n    host = host || '0.0.0.0';\n  }\n\n  this.type = 'server';\n  this.server = net.createServer(this.onconnect.bind(this));\n  debug('bind %s:%s', host, port);\n  this.server.on('listening', this.emit.bind(this, 'bind'));\n\n  if (unixSocket) {\n    // TODO: move out\n    this.server.on('error', function (e) {\n      debug('Got error while trying to bind', e.stack || e);\n\n      if (e.code == 'EADDRINUSE') {\n        // Unix file socket and error EADDRINUSE is the case if\n        // the file socket exists. We check if other processes\n        // listen on file socket, otherwise it is a stale socket\n        // that we could reopen\n        // We try to connect to socket via plain network socket\n        var clientSocket = new net.Socket();\n        clientSocket.on('error', function (e2) {\n          debug('Got sub-error', e2);\n\n          if (e2.code == 'ECONNREFUSED' || e2.code == 'ENOENT') {\n            // No other server listening, so we can delete stale\n            // socket file and reopen server socket\n            try {\n              fs.unlinkSync(port);\n            } catch (e) {}\n\n            self.server.listen(port, host, fn);\n          }\n        });\n        clientSocket.connect({\n          path: port\n        }, function () {\n          // Connection is possible, so other server is listening\n          // on this file socket\n          if (fn) return fn(new Error('Process already listening on socket ' + port));\n        });\n      } else {\n        try {\n          fs.unlinkSync(port);\n        } catch (e) {}\n\n        self.server.listen(port, host, fn);\n      }\n    });\n  }\n\n  this.server.listen(port, host, fn);\n  return this;\n};","map":{"version":3,"sources":["/Users/samianki/node_modules/pm2-axon/lib/sockets/sock.js"],"names":["Emitter","require","EventEmitter","Configurable","debug","Message","Parser","Stream","url","net","fs","ignore","module","exports","Socket","self","opts","server","socks","settings","set","Infinity","String","process","pid","prototype","__proto__","use","plugin","pack","args","msg","toBuffer","closeSockets","length","forEach","sock","destroy","close","fn","closing","closeServer","on","emit","bind","address","addr","string","port","removeSocket","i","indexOf","splice","addSocket","parser","push","pipe","onmessage","handleErrors","err","code","message","buf","apply","concat","connect","host","type","Error","undefined","parse","pathname","hostname","parseInt","max","get","setNoDelay","connected","retry","setTimeout","Math","round","min","onconnect","remoteAddress","remotePort","_pipeName","unixSocket","createServer","e","stack","clientSocket","e2","unlinkSync","listen","path"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('events').EventEmitter;\nvar Configurable = require('../configurable');\nvar debug = require('debug')('axon:sock');\nvar Message = require('amp-message');\nvar Parser = require('amp').Stream;\nvar url = require('url');\nvar net = require('net');\nvar fs = require('fs');\n\n/**\n * Errors to ignore.\n */\n\nvar ignore = [\n  'ECONNREFUSED',\n  'ECONNRESET',\n  'ETIMEDOUT',\n  'EHOSTUNREACH',\n  'ENETUNREACH',\n  'ENETDOWN',\n  'EPIPE',\n  'ENOENT'\n];\n\n/**\n * Expose `Socket`.\n */\n\nmodule.exports = Socket;\n\n/**\n * Initialize a new `Socket`.\n *\n * A \"Socket\" encapsulates the ability of being\n * the \"client\" or the \"server\" depending on\n * whether `connect()` or `bind()` was called.\n *\n * @api private\n */\n\nfunction Socket() {\n  var self = this;\n  this.opts = {};\n  this.server = null;\n  this.socks = [];\n  this.settings = {};\n  this.set('hwm', Infinity);\n  this.set('identity', String(process.pid));\n  this.set('retry timeout', 100);\n  this.set('retry max timeout', 5000);\n}\n\n/**\n * Inherit from `Emitter.prototype`.\n */\n\nSocket.prototype.__proto__ = Emitter.prototype;\n\n/**\n * Make it configurable `.set()` etc.\n */\n\nConfigurable(Socket.prototype);\n\n/**\n * Use the given `plugin`.\n *\n * @param {Function} plugin\n * @api private\n */\n\nSocket.prototype.use = function(plugin){\n  plugin(this);\n  return this;\n};\n\n/**\n * Creates a new `Message` and write the `args`.\n *\n * @param {Array} args\n * @return {Buffer}\n * @api private\n */\n\nSocket.prototype.pack = function(args){\n  var msg = new Message(args);\n  return msg.toBuffer();\n};\n\n/**\n * Close all open underlying sockets.\n *\n * @api private\n */\n\nSocket.prototype.closeSockets = function(){\n  debug('closing %d connections', this.socks.length);\n  this.socks.forEach(function(sock){\n    sock.destroy();\n  });\n};\n\n/**\n * Close the socket.\n *\n * Delegates to the server or clients\n * based on the socket `type`.\n *\n * @param {Function} [fn]\n * @api public\n */\n\nSocket.prototype.close = function(fn){\n  debug('closing');\n  this.closing = true;\n  this.closeSockets();\n  if (this.server) this.closeServer(fn);\n};\n\n/**\n * Close the server.\n *\n * @param {Function} [fn]\n * @api public\n */\n\nSocket.prototype.closeServer = function(fn){\n  debug('closing server');\n  this.server.on('close', this.emit.bind(this, 'close'));\n  this.server.close();\n  fn && fn();\n};\n\n/**\n * Return the server address.\n *\n * @return {Object}\n * @api public\n */\n\nSocket.prototype.address = function(){\n  if (!this.server) return;\n  var addr = this.server.address();\n  addr.string = 'tcp://' + addr.address + ':' + addr.port;\n  return addr;\n};\n\n/**\n * Remove `sock`.\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.removeSocket = function(sock){\n  var i = this.socks.indexOf(sock);\n  if (!~i) return;\n  debug('remove socket %d', i);\n  this.socks.splice(i, 1);\n};\n\n/**\n * Add `sock`.\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.addSocket = function(sock){\n  var parser = new Parser;\n  var i = this.socks.push(sock) - 1;\n  debug('add socket %d', i);\n  sock.pipe(parser);\n  parser.on('data', this.onmessage(sock));\n};\n\n/**\n * Handle `sock` errors.\n *\n * Emits:\n *\n *  - `error` (err) when the error is not ignored\n *  - `ignored error` (err) when the error is ignored\n *  - `socket error` (err) regardless of ignoring\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.handleErrors = function(sock){\n  var self = this;\n  sock.on('error', function(err){\n    debug('error %s', err.code || err.message);\n    self.emit('socket error', err);\n    self.removeSocket(sock);\n    if (!~ignore.indexOf(err.code)) return self.emit('error', err);\n    debug('ignored %s', err.code);\n    self.emit('ignored error', err);\n  });\n};\n\n/**\n * Handles framed messages emitted from the parser, by\n * default it will go ahead and emit the \"message\" events on\n * the socket. However, if the \"higher level\" socket needs\n * to hook into the messages before they are emitted, it\n * should override this method and take care of everything\n * it self, including emitted the \"message\" event.\n *\n * @param {net.Socket} sock\n * @return {Function} closure(msg, mulitpart)\n * @api private\n */\n\nSocket.prototype.onmessage = function(sock){\n  var self = this;\n  return function(buf){\n    var msg = new Message(buf);\n    self.emit.apply(self, ['message'].concat(msg.args), sock);\n  };\n};\n\n/**\n * Connect to `port` at `host` and invoke `fn()`.\n *\n * Defaults `host` to localhost.\n *\n * TODO: needs big cleanup\n *\n * @param {Number|String} port\n * @param {String} host\n * @param {Function} fn\n * @return {Socket}\n * @api public\n */\n\nSocket.prototype.connect = function(port, host, fn){\n  var self = this;\n  if ('server' == this.type) throw new Error('cannot connect() after bind()');\n  if ('function' == typeof host) fn = host, host = undefined;\n\n  if ('string' == typeof port) {\n    port = url.parse(port);\n\n    if (port.pathname) {\n      fn = host;\n      host = null;\n      fn = undefined;\n      port = port.pathname;\n    } else {\n      host = port.hostname || '0.0.0.0';\n      port = parseInt(port.port, 10);\n    }\n  } else {\n    host = host || '0.0.0.0';\n  }\n\n  var max = self.get('retry max timeout');\n  var sock = new net.Socket;\n  sock.setNoDelay();\n  this.type = 'client';\n  port = port;\n\n  this.handleErrors(sock);\n\n  sock.on('close', function(){\n    self.connected = false;\n    self.removeSocket(sock);\n    if (self.closing) return self.emit('close');\n    var retry = self.retry || self.get('retry timeout');\n    if (retry === 0) return self.emit('close');\n    setTimeout(function(){\n      debug('attempting reconnect');\n      self.emit('reconnect attempt');\n      sock.destroy();\n      self.connect(port, host);\n      self.retry = Math.round(Math.min(max, retry * 1.5));\n    }, retry);\n  });\n\n  sock.on('connect', function(){\n    debug('connect');\n    self.connected = true;\n    self.addSocket(sock);\n    self.retry = self.get('retry timeout');\n    self.emit('connect');\n    fn && fn();\n  });\n\n  debug('connect attempt %s:%s', host, port);\n  sock.connect(port, host);\n  return this;\n};\n\n/**\n * Handle connection.\n *\n * @param {Socket} sock\n * @api private\n */\n\nSocket.prototype.onconnect = function(sock){\n  var self = this;\n  var addr = null;\n\n  if (sock.remoteAddress && sock.remotePort)\n    addr = sock.remoteAddress + ':' + sock.remotePort;\n  else if (sock.server && sock.server._pipeName)\n    addr = sock.server._pipeName;\n\n  debug('accept %s', addr);\n  this.addSocket(sock);\n  this.handleErrors(sock);\n  this.emit('connect', sock);\n  sock.on('close', function(){\n    debug('disconnect %s', addr);\n    self.emit('disconnect', sock);\n    self.removeSocket(sock);\n  });\n};\n\n/**\n * Bind to `port` at `host` and invoke `fn()`.\n *\n * Defaults `host` to INADDR_ANY.\n *\n * Emits:\n *\n *  - `connection` when a client connects\n *  - `disconnect` when a client disconnects\n *  - `bind` when bound and listening\n *\n * @param {Number|String} port\n * @param {Function} fn\n * @return {Socket}\n * @api public\n */\n\nSocket.prototype.bind = function(port, host, fn){\n  var self = this;\n  if ('client' == this.type) throw new Error('cannot bind() after connect()');\n  if ('function' == typeof host) fn = host, host = undefined;\n\n  var unixSocket = false;\n\n  if ('string' == typeof port) {\n    port = url.parse(port);\n\n    if (port.pathname) {\n      fn = host;\n      host = null;\n      port = port.pathname;\n      unixSocket = true;\n    } else {\n      host = port.hostname || '0.0.0.0';\n      port = parseInt(port.port, 10);\n    }\n  } else {\n    host = host || '0.0.0.0';\n  }\n\n  this.type = 'server';\n\n  this.server = net.createServer(this.onconnect.bind(this));\n\n  debug('bind %s:%s', host, port);\n  this.server.on('listening', this.emit.bind(this, 'bind'));\n\n  if (unixSocket) {\n    // TODO: move out\n    this.server.on('error', function(e) {\n      debug('Got error while trying to bind', e.stack || e);\n      if (e.code == 'EADDRINUSE') {\n        // Unix file socket and error EADDRINUSE is the case if\n        // the file socket exists. We check if other processes\n        // listen on file socket, otherwise it is a stale socket\n        // that we could reopen\n        // We try to connect to socket via plain network socket\n        var clientSocket = new net.Socket();\n\n        clientSocket.on('error', function(e2) {\n          debug('Got sub-error', e2);\n          if (e2.code == 'ECONNREFUSED' || e2.code == 'ENOENT') {\n            // No other server listening, so we can delete stale\n            // socket file and reopen server socket\n            try {\n              fs.unlinkSync(port);\n            } catch(e) {}\n            self.server.listen(port, host, fn);\n          }\n        });\n\n        clientSocket.connect({path: port}, function() {\n          // Connection is possible, so other server is listening\n          // on this file socket\n          if (fn) return fn(new Error('Process already listening on socket ' + port));\n        });\n      }\n      else {\n        try {\n          fs.unlinkSync(port);\n        } catch(e) {}\n        self.server.listen(port, host, fn);\n      }\n    });\n  }\n\n  this.server.listen(port, host, fn);\n  return this;\n};\n"]},"metadata":{},"sourceType":"script"}