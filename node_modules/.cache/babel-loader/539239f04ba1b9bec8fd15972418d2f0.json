{"ast":null,"code":"'use strict';\n\nconst colors = require('ansi-colors');\n\nconst clean = (str = '') => {\n  return typeof str === 'string' ? str.replace(/^['\"]|['\"]$/g, '') : '';\n};\n/**\n * This file contains the interpolation and rendering logic for\n * the Snippet prompt.\n */\n\n\nclass Item {\n  constructor(token) {\n    this.name = token.key;\n    this.field = token.field || {};\n    this.value = clean(token.initial || this.field.initial || '');\n    this.message = token.message || this.name;\n    this.cursor = 0;\n    this.input = '';\n    this.lines = [];\n  }\n\n}\n\nconst tokenize = async (options = {}, defaults = {}, fn = token => token) => {\n  let unique = new Set();\n  let fields = options.fields || [];\n  let input = options.template;\n  let tabstops = [];\n  let items = [];\n  let keys = [];\n  let line = 1;\n\n  if (typeof input === 'function') {\n    input = await input();\n  }\n\n  let i = -1;\n\n  let next = () => input[++i];\n\n  let peek = () => input[i + 1];\n\n  let push = token => {\n    token.line = line;\n    tabstops.push(token);\n  };\n\n  push({\n    type: 'bos',\n    value: ''\n  });\n\n  while (i < input.length - 1) {\n    let value = next();\n\n    if (/^[^\\S\\n ]$/.test(value)) {\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === '\\n') {\n      push({\n        type: 'newline',\n        value\n      });\n      line++;\n      continue;\n    }\n\n    if (value === '\\\\') {\n      value += next();\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if ((value === '$' || value === '#' || value === '{') && peek() === '{') {\n      let n = next();\n      value += n;\n      let token = {\n        type: 'template',\n        open: value,\n        inner: '',\n        close: '',\n        value\n      };\n      let ch;\n\n      while (ch = next()) {\n        if (ch === '}') {\n          if (peek() === '}') ch += next();\n          token.value += ch;\n          token.close = ch;\n          break;\n        }\n\n        if (ch === ':') {\n          token.initial = '';\n          token.key = token.inner;\n        } else if (token.initial !== void 0) {\n          token.initial += ch;\n        }\n\n        token.value += ch;\n        token.inner += ch;\n      }\n\n      token.template = token.open + (token.initial || token.inner) + token.close;\n      token.key = token.key || token.inner;\n\n      if (defaults.hasOwnProperty(token.key)) {\n        token.initial = defaults[token.key];\n      }\n\n      token = fn(token);\n      push(token);\n      keys.push(token.key);\n      unique.add(token.key);\n      let item = items.find(item => item.name === token.key);\n      token.field = fields.find(ch => ch.name === token.key);\n\n      if (!item) {\n        item = new Item(token);\n        items.push(item);\n      }\n\n      item.lines.push(token.line - 1);\n      continue;\n    }\n\n    let last = tabstops[tabstops.length - 1];\n\n    if (last.type === 'text' && last.line === line) {\n      last.value += value;\n    } else {\n      push({\n        type: 'text',\n        value\n      });\n    }\n  }\n\n  push({\n    type: 'eos',\n    value: ''\n  });\n  return {\n    input,\n    tabstops,\n    unique,\n    keys,\n    items\n  };\n};\n\nmodule.exports = async prompt => {\n  let options = prompt.options;\n  let required = new Set(options.required === true ? [] : options.required || []);\n  let defaults = { ...options.values,\n    ...options.initial\n  };\n  let {\n    tabstops,\n    items,\n    keys\n  } = await tokenize(options, defaults);\n  let result = createFn('result', prompt, options);\n  let format = createFn('format', prompt, options);\n  let isValid = createFn('validate', prompt, options, true);\n  let isVal = prompt.isValue.bind(prompt);\n  return async (state = {}, submitted = false) => {\n    let index = 0;\n    state.required = required;\n    state.items = items;\n    state.keys = keys;\n    state.output = '';\n\n    let validate = async (value, state, item, index) => {\n      let error = await isValid(value, state, item, index);\n\n      if (error === false) {\n        return 'Invalid field ' + item.name;\n      }\n\n      return error;\n    };\n\n    for (let token of tabstops) {\n      let value = token.value;\n      let key = token.key;\n\n      if (token.type !== 'template') {\n        if (value) state.output += value;\n        continue;\n      }\n\n      if (token.type === 'template') {\n        let item = items.find(ch => ch.name === key);\n\n        if (options.required === true) {\n          state.required.add(item.name);\n        }\n\n        let val = [item.input, state.values[item.value], item.value, value].find(isVal);\n        let field = item.field || {};\n        let message = field.message || token.inner;\n\n        if (submitted) {\n          let error = await validate(state.values[key], state, item, index);\n\n          if (error && typeof error === 'string' || error === false) {\n            state.invalid.set(key, error);\n            continue;\n          }\n\n          state.invalid.delete(key);\n          let res = await result(state.values[key], state, item, index);\n          state.output += colors.unstyle(res);\n          continue;\n        }\n\n        item.placeholder = false;\n        let before = value;\n        value = await format(value, state, item, index);\n\n        if (val !== value) {\n          state.values[key] = val;\n          value = prompt.styles.typing(val);\n          state.missing.delete(message);\n        } else {\n          state.values[key] = void 0;\n          val = `<${message}>`;\n          value = prompt.styles.primary(val);\n          item.placeholder = true;\n\n          if (state.required.has(key)) {\n            state.missing.add(message);\n          }\n        }\n\n        if (state.missing.has(message) && state.validating) {\n          value = prompt.styles.warning(val);\n        }\n\n        if (state.invalid.has(key) && state.validating) {\n          value = prompt.styles.danger(val);\n        }\n\n        if (index === state.index) {\n          if (before !== value) {\n            value = prompt.styles.underline(value);\n          } else {\n            value = prompt.styles.heading(colors.unstyle(value));\n          }\n        }\n\n        index++;\n      }\n\n      if (value) {\n        state.output += value;\n      }\n    }\n\n    let lines = state.output.split('\\n').map(l => ' ' + l);\n    let len = items.length;\n    let done = 0;\n\n    for (let item of items) {\n      if (state.invalid.has(item.name)) {\n        item.lines.forEach(i => {\n          if (lines[i][0] !== ' ') return;\n          lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);\n        });\n      }\n\n      if (prompt.isValue(state.values[item.name])) {\n        done++;\n      }\n    }\n\n    state.completed = (done / len * 100).toFixed(0);\n    state.output = lines.join('\\n');\n    return state.output;\n  };\n};\n\nfunction createFn(prop, prompt, options, fallback) {\n  return (value, state, item, index) => {\n    if (typeof item.field[prop] === 'function') {\n      return item.field[prop].call(prompt, value, state, item, index);\n    }\n\n    return [fallback, value].find(v => prompt.isValue(v));\n  };\n}","map":{"version":3,"sources":["/Users/samianki/node_modules/enquirer/lib/interpolate.js"],"names":["colors","require","clean","str","replace","Item","constructor","token","name","key","field","value","initial","message","cursor","input","lines","tokenize","options","defaults","fn","unique","Set","fields","template","tabstops","items","keys","line","i","next","peek","push","type","length","test","n","open","inner","close","ch","hasOwnProperty","add","item","find","last","module","exports","prompt","required","values","result","createFn","format","isValid","isVal","isValue","bind","state","submitted","index","output","validate","error","val","invalid","set","delete","res","unstyle","placeholder","before","styles","typing","missing","primary","has","validating","warning","danger","underline","heading","split","map","l","len","done","forEach","symbols","bullet","slice","completed","toFixed","join","prop","fallback","call","v"],"mappings":"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","sourcesContent":["'use strict';\n\nconst colors = require('ansi-colors');\nconst clean = (str = '') => {\n  return typeof str === 'string' ? str.replace(/^['\"]|['\"]$/g, '') : '';\n};\n\n/**\n * This file contains the interpolation and rendering logic for\n * the Snippet prompt.\n */\n\nclass Item {\n  constructor(token) {\n    this.name = token.key;\n    this.field = token.field || {};\n    this.value = clean(token.initial || this.field.initial || '');\n    this.message = token.message || this.name;\n    this.cursor = 0;\n    this.input = '';\n    this.lines = [];\n  }\n}\n\nconst tokenize = async(options = {}, defaults = {}, fn = token => token) => {\n  let unique = new Set();\n  let fields = options.fields || [];\n  let input = options.template;\n  let tabstops = [];\n  let items = [];\n  let keys = [];\n  let line = 1;\n\n  if (typeof input === 'function') {\n    input = await input();\n  }\n\n  let i = -1;\n  let next = () => input[++i];\n  let peek = () => input[i + 1];\n  let push = token => {\n    token.line = line;\n    tabstops.push(token);\n  };\n\n  push({ type: 'bos', value: '' });\n\n  while (i < input.length - 1) {\n    let value = next();\n\n    if (/^[^\\S\\n ]$/.test(value)) {\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === '\\n') {\n      push({ type: 'newline', value });\n      line++;\n      continue;\n    }\n\n    if (value === '\\\\') {\n      value += next();\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if ((value === '$' || value === '#' || value === '{') && peek() === '{') {\n      let n = next();\n      value += n;\n\n      let token = { type: 'template', open: value, inner: '', close: '', value };\n      let ch;\n\n      while ((ch = next())) {\n        if (ch === '}') {\n          if (peek() === '}') ch += next();\n          token.value += ch;\n          token.close = ch;\n          break;\n        }\n\n        if (ch === ':') {\n          token.initial = '';\n          token.key = token.inner;\n        } else if (token.initial !== void 0) {\n          token.initial += ch;\n        }\n\n        token.value += ch;\n        token.inner += ch;\n      }\n\n      token.template = token.open + (token.initial || token.inner) + token.close;\n      token.key = token.key || token.inner;\n\n      if (defaults.hasOwnProperty(token.key)) {\n        token.initial = defaults[token.key];\n      }\n\n      token = fn(token);\n      push(token);\n\n      keys.push(token.key);\n      unique.add(token.key);\n\n      let item = items.find(item => item.name === token.key);\n      token.field = fields.find(ch => ch.name === token.key);\n\n      if (!item) {\n        item = new Item(token);\n        items.push(item);\n      }\n\n      item.lines.push(token.line - 1);\n      continue;\n    }\n\n    let last = tabstops[tabstops.length - 1];\n    if (last.type === 'text' && last.line === line) {\n      last.value += value;\n    } else {\n      push({ type: 'text', value });\n    }\n  }\n\n  push({ type: 'eos', value: '' });\n  return { input, tabstops, unique, keys, items };\n};\n\nmodule.exports = async prompt => {\n  let options = prompt.options;\n  let required = new Set(options.required === true ? [] : (options.required || []));\n  let defaults = { ...options.values, ...options.initial };\n  let { tabstops, items, keys } = await tokenize(options, defaults);\n\n  let result = createFn('result', prompt, options);\n  let format = createFn('format', prompt, options);\n  let isValid = createFn('validate', prompt, options, true);\n  let isVal = prompt.isValue.bind(prompt);\n\n  return async(state = {}, submitted = false) => {\n    let index = 0;\n\n    state.required = required;\n    state.items = items;\n    state.keys = keys;\n    state.output = '';\n\n    let validate = async(value, state, item, index) => {\n      let error = await isValid(value, state, item, index);\n      if (error === false) {\n        return 'Invalid field ' + item.name;\n      }\n      return error;\n    };\n\n    for (let token of tabstops) {\n      let value = token.value;\n      let key = token.key;\n\n      if (token.type !== 'template') {\n        if (value) state.output += value;\n        continue;\n      }\n\n      if (token.type === 'template') {\n        let item = items.find(ch => ch.name === key);\n\n        if (options.required === true) {\n          state.required.add(item.name);\n        }\n\n        let val = [item.input, state.values[item.value], item.value, value].find(isVal);\n        let field = item.field || {};\n        let message = field.message || token.inner;\n\n        if (submitted) {\n          let error = await validate(state.values[key], state, item, index);\n          if ((error && typeof error === 'string') || error === false) {\n            state.invalid.set(key, error);\n            continue;\n          }\n\n          state.invalid.delete(key);\n          let res = await result(state.values[key], state, item, index);\n          state.output += colors.unstyle(res);\n          continue;\n        }\n\n        item.placeholder = false;\n\n        let before = value;\n        value = await format(value, state, item, index);\n\n        if (val !== value) {\n          state.values[key] = val;\n          value = prompt.styles.typing(val);\n          state.missing.delete(message);\n\n        } else {\n          state.values[key] = void 0;\n          val = `<${message}>`;\n          value = prompt.styles.primary(val);\n          item.placeholder = true;\n\n          if (state.required.has(key)) {\n            state.missing.add(message);\n          }\n        }\n\n        if (state.missing.has(message) && state.validating) {\n          value = prompt.styles.warning(val);\n        }\n\n        if (state.invalid.has(key) && state.validating) {\n          value = prompt.styles.danger(val);\n        }\n\n        if (index === state.index) {\n          if (before !== value) {\n            value = prompt.styles.underline(value);\n          } else {\n            value = prompt.styles.heading(colors.unstyle(value));\n          }\n        }\n\n        index++;\n      }\n\n      if (value) {\n        state.output += value;\n      }\n    }\n\n    let lines = state.output.split('\\n').map(l => ' ' + l);\n    let len = items.length;\n    let done = 0;\n\n    for (let item of items) {\n      if (state.invalid.has(item.name)) {\n        item.lines.forEach(i => {\n          if (lines[i][0] !== ' ') return;\n          lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);\n        });\n      }\n\n      if (prompt.isValue(state.values[item.name])) {\n        done++;\n      }\n    }\n\n    state.completed = ((done / len) * 100).toFixed(0);\n    state.output = lines.join('\\n');\n    return state.output;\n  };\n};\n\nfunction createFn(prop, prompt, options, fallback) {\n  return (value, state, item, index) => {\n    if (typeof item.field[prop] === 'function') {\n      return item.field[prop].call(prompt, value, state, item, index);\n    }\n    return [fallback, value].find(v => prompt.isValue(v));\n  };\n}\n"]},"metadata":{},"sourceType":"script"}