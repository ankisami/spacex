{"ast":null,"code":"'use strict';\n\nconst colors = require('ansi-colors');\n\nconst SelectPrompt = require('./select');\n\nconst placeholder = require('../placeholder');\n\nclass FormPrompt extends SelectPrompt {\n  constructor(options) {\n    super({ ...options,\n      multiple: true\n    });\n    this.type = 'form';\n    this.initial = this.options.initial;\n    this.align = [this.options.align, 'right'].find(v => v != null);\n    this.emptyError = '';\n    this.values = {};\n  }\n\n  async reset(first) {\n    await super.reset();\n    if (first === true) this._index = this.index;\n    this.index = this._index;\n    this.values = {};\n    this.choices.forEach(choice => choice.reset && choice.reset());\n    return this.render();\n  }\n\n  dispatch(char) {\n    return !!char && this.append(char);\n  }\n\n  append(char) {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    let {\n      cursor,\n      input\n    } = choice;\n    choice.value = choice.input = input.slice(0, cursor) + char + input.slice(cursor);\n    choice.cursor++;\n    return this.render();\n  }\n\n  delete() {\n    let choice = this.focused;\n    if (!choice || choice.cursor <= 0) return this.alert();\n    let {\n      cursor,\n      input\n    } = choice;\n    choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);\n    choice.cursor--;\n    return this.render();\n  }\n\n  deleteForward() {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    let {\n      cursor,\n      input\n    } = choice;\n    if (input[cursor] === void 0) return this.alert();\n    let str = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);\n    choice.value = choice.input = str;\n    return this.render();\n  }\n\n  right() {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    if (choice.cursor >= choice.input.length) return this.alert();\n    choice.cursor++;\n    return this.render();\n  }\n\n  left() {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    if (choice.cursor <= 0) return this.alert();\n    choice.cursor--;\n    return this.render();\n  }\n\n  space(ch, key) {\n    return this.dispatch(ch, key);\n  }\n\n  number(ch, key) {\n    return this.dispatch(ch, key);\n  }\n\n  next() {\n    let ch = this.focused;\n    if (!ch) return this.alert();\n    let {\n      initial,\n      input\n    } = ch;\n\n    if (initial && initial.startsWith(input) && input !== initial) {\n      ch.value = ch.input = initial;\n      ch.cursor = ch.value.length;\n      return this.render();\n    }\n\n    return super.next();\n  }\n\n  prev() {\n    let ch = this.focused;\n    if (!ch) return this.alert();\n    if (ch.cursor === 0) return super.prev();\n    ch.value = ch.input = '';\n    ch.cursor = 0;\n    return this.render();\n  }\n\n  separator() {\n    return '';\n  }\n\n  format(value) {\n    return !this.state.submitted ? super.format(value) : '';\n  }\n\n  pointer() {\n    return '';\n  }\n\n  indicator(choice) {\n    return choice.input ? '⦿' : '⊙';\n  }\n\n  async choiceSeparator(choice, i) {\n    let sep = (await this.resolve(choice.separator, this.state, choice, i)) || ':';\n    return sep ? ' ' + this.styles.disabled(sep) : '';\n  }\n\n  async renderChoice(choice, i) {\n    await this.onChoice(choice, i);\n    let {\n      state,\n      styles\n    } = this;\n    let {\n      cursor,\n      initial = '',\n      name,\n      hint,\n      input = ''\n    } = choice;\n    let {\n      muted,\n      submitted,\n      primary,\n      danger\n    } = styles;\n    let help = hint;\n    let focused = this.index === i;\n\n    let validate = choice.validate || (() => true);\n\n    let sep = await this.choiceSeparator(choice, i);\n    let msg = choice.message;\n    if (this.align === 'right') msg = msg.padStart(this.longest + 1, ' ');\n    if (this.align === 'left') msg = msg.padEnd(this.longest + 1, ' '); // re-populate the form values (answers) object\n\n    let value = this.values[name] = input || initial;\n    let color = input ? 'success' : 'dark';\n\n    if ((await validate.call(choice, value, this.state)) !== true) {\n      color = 'danger';\n    }\n\n    let style = styles[color];\n    let indicator = style(await this.indicator(choice, i)) + (choice.pad || '');\n    let indent = this.indent(choice);\n\n    let line = () => [indent, indicator, msg + sep, input, help].filter(Boolean).join(' ');\n\n    if (state.submitted) {\n      msg = colors.unstyle(msg);\n      input = submitted(input);\n      help = '';\n      return line();\n    }\n\n    if (choice.format) {\n      input = await choice.format.call(this, input, choice, i);\n    } else {\n      let color = this.styles.muted;\n      let options = {\n        input,\n        initial,\n        pos: cursor,\n        showCursor: focused,\n        color\n      };\n      input = placeholder(this, options);\n    }\n\n    if (!this.isValue(input)) {\n      input = this.styles.muted(this.symbols.ellipsis);\n    }\n\n    if (choice.result) {\n      this.values[name] = await choice.result.call(this, value, choice, i);\n    }\n\n    if (focused) {\n      msg = primary(msg);\n    }\n\n    if (choice.error) {\n      input += (input ? ' ' : '') + danger(choice.error.trim());\n    } else if (choice.hint) {\n      input += (input ? ' ' : '') + muted(choice.hint.trim());\n    }\n\n    return line();\n  }\n\n  async submit() {\n    this.value = this.values;\n    return super.base.submit.call(this);\n  }\n\n}\n\nmodule.exports = FormPrompt;","map":{"version":3,"sources":["/Users/samianki/node_modules/enquirer/lib/prompts/form.js"],"names":["colors","require","SelectPrompt","placeholder","FormPrompt","constructor","options","multiple","type","initial","align","find","v","emptyError","values","reset","first","_index","index","choices","forEach","choice","render","dispatch","char","append","focused","alert","cursor","input","value","slice","delete","deleteForward","str","right","length","left","space","ch","key","number","next","startsWith","prev","separator","format","state","submitted","pointer","indicator","choiceSeparator","i","sep","resolve","styles","disabled","renderChoice","onChoice","name","hint","muted","primary","danger","help","validate","msg","message","padStart","longest","padEnd","color","call","style","pad","indent","line","filter","Boolean","join","unstyle","pos","showCursor","isValue","symbols","ellipsis","result","error","trim","submit","base","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst colors = require('ansi-colors');\nconst SelectPrompt = require('./select');\nconst placeholder = require('../placeholder');\n\nclass FormPrompt extends SelectPrompt {\n  constructor(options) {\n    super({ ...options, multiple: true });\n    this.type = 'form';\n    this.initial = this.options.initial;\n    this.align = [this.options.align, 'right'].find(v => v != null);\n    this.emptyError = '';\n    this.values = {};\n  }\n\n  async reset(first) {\n    await super.reset();\n    if (first === true) this._index = this.index;\n    this.index = this._index;\n    this.values = {};\n    this.choices.forEach(choice => choice.reset && choice.reset());\n    return this.render();\n  }\n\n  dispatch(char) {\n    return !!char && this.append(char);\n  }\n\n  append(char) {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    let { cursor, input } = choice;\n    choice.value = choice.input = input.slice(0, cursor) + char + input.slice(cursor);\n    choice.cursor++;\n    return this.render();\n  }\n\n  delete() {\n    let choice = this.focused;\n    if (!choice || choice.cursor <= 0) return this.alert();\n    let { cursor, input } = choice;\n    choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);\n    choice.cursor--;\n    return this.render();\n  }\n\n  deleteForward() {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    let { cursor, input } = choice;\n    if (input[cursor] === void 0) return this.alert();\n    let str = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);\n    choice.value = choice.input = str;\n    return this.render();\n  }\n\n  right() {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    if (choice.cursor >= choice.input.length) return this.alert();\n    choice.cursor++;\n    return this.render();\n  }\n\n  left() {\n    let choice = this.focused;\n    if (!choice) return this.alert();\n    if (choice.cursor <= 0) return this.alert();\n    choice.cursor--;\n    return this.render();\n  }\n\n  space(ch, key) {\n    return this.dispatch(ch, key);\n  }\n\n  number(ch, key) {\n    return this.dispatch(ch, key);\n  }\n\n  next() {\n    let ch = this.focused;\n    if (!ch) return this.alert();\n    let { initial, input } = ch;\n    if (initial && initial.startsWith(input) && input !== initial) {\n      ch.value = ch.input = initial;\n      ch.cursor = ch.value.length;\n      return this.render();\n    }\n    return super.next();\n  }\n\n  prev() {\n    let ch = this.focused;\n    if (!ch) return this.alert();\n    if (ch.cursor === 0) return super.prev();\n    ch.value = ch.input = '';\n    ch.cursor = 0;\n    return this.render();\n  }\n\n  separator() {\n    return '';\n  }\n\n  format(value) {\n    return !this.state.submitted ? super.format(value) : '';\n  }\n\n  pointer() {\n    return '';\n  }\n\n  indicator(choice) {\n    return choice.input ? '⦿' : '⊙';\n  }\n\n  async choiceSeparator(choice, i) {\n    let sep = await this.resolve(choice.separator, this.state, choice, i) || ':';\n    return sep ? ' ' + this.styles.disabled(sep) : '';\n  }\n\n  async renderChoice(choice, i) {\n    await this.onChoice(choice, i);\n\n    let { state, styles } = this;\n    let { cursor, initial = '', name, hint, input = '' } = choice;\n    let { muted, submitted, primary, danger } = styles;\n\n    let help = hint;\n    let focused = this.index === i;\n    let validate = choice.validate || (() => true);\n    let sep = await this.choiceSeparator(choice, i);\n    let msg = choice.message;\n\n    if (this.align === 'right') msg = msg.padStart(this.longest + 1, ' ');\n    if (this.align === 'left') msg = msg.padEnd(this.longest + 1, ' ');\n\n    // re-populate the form values (answers) object\n    let value = this.values[name] = (input || initial);\n    let color = input ? 'success' : 'dark';\n\n    if ((await validate.call(choice, value, this.state)) !== true) {\n      color = 'danger';\n    }\n\n    let style = styles[color];\n    let indicator = style(await this.indicator(choice, i)) + (choice.pad || '');\n\n    let indent = this.indent(choice);\n    let line = () => [indent, indicator, msg + sep, input, help].filter(Boolean).join(' ');\n\n    if (state.submitted) {\n      msg = colors.unstyle(msg);\n      input = submitted(input);\n      help = '';\n      return line();\n    }\n\n    if (choice.format) {\n      input = await choice.format.call(this, input, choice, i);\n    } else {\n      let color = this.styles.muted;\n      let options = { input, initial, pos: cursor, showCursor: focused, color };\n      input = placeholder(this, options);\n    }\n\n    if (!this.isValue(input)) {\n      input = this.styles.muted(this.symbols.ellipsis);\n    }\n\n    if (choice.result) {\n      this.values[name] = await choice.result.call(this, value, choice, i);\n    }\n\n    if (focused) {\n      msg = primary(msg);\n    }\n\n    if (choice.error) {\n      input += (input ? ' ' : '') + danger(choice.error.trim());\n    } else if (choice.hint) {\n      input += (input ? ' ' : '') + muted(choice.hint.trim());\n    }\n\n    return line();\n  }\n\n  async submit() {\n    this.value = this.values;\n    return super.base.submit.call(this);\n  }\n}\n\nmodule.exports = FormPrompt;\n"]},"metadata":{},"sourceType":"script"}