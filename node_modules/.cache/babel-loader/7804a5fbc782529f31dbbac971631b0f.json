{"ast":null,"code":"/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar fs = require('fs');\n\nvar max_bytes = 512;\n\nmodule.exports = function (bytes, size) {\n  // Read the file with no encoding for raw buffer access.\n  if (size === undefined) {\n    var file = bytes;\n\n    try {\n      if (!fs.statSync(file).isFile()) return false;\n    } catch (err) {// otherwise continue on\n    }\n\n    var descriptor = fs.openSync(file, 'r');\n\n    try {\n      bytes = Buffer.alloc(max_bytes);\n      size = fs.readSync(descriptor, bytes, 0, bytes.length, 0);\n    } finally {\n      fs.closeSync(descriptor);\n    }\n  } // async version has a function instead of a `size`\n  else if (typeof size === \"function\") {\n      var file = bytes,\n          callback = size;\n      fs.stat(file, function (err, stat) {\n        if (err || !stat.isFile()) return callback(null, false);\n        fs.open(file, 'r', function (err, descriptor) {\n          if (err) return callback(err);\n          var bytes = Buffer.alloc(max_bytes); // Read the file with no encoding for raw buffer access.\n\n          fs.read(descriptor, bytes, 0, bytes.length, 0, function (err, size, bytes) {\n            fs.close(descriptor, function (err2) {\n              if (err || err2) return callback(err || err2);\n              return callback(null, isBinaryCheck(bytes, size));\n            });\n          });\n        });\n      });\n    }\n\n  return isBinaryCheck(bytes, size);\n};\n\nfunction isBinaryCheck(bytes, size) {\n  if (size === 0) return false;\n  var suspicious_bytes = 0;\n  var total_bytes = Math.min(size, max_bytes);\n\n  if (size >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) {\n    // UTF-8 BOM. This isn't binary.\n    return false;\n  }\n\n  for (var i = 0; i < total_bytes; i++) {\n    if (bytes[i] === 0) {\n      // NULL byte--it's binary!\n      return true;\n    } else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {\n      // UTF-8 detection\n      if (bytes[i] > 193 && bytes[i] < 224 && i + 1 < total_bytes) {\n        i++;\n\n        if (bytes[i] > 127 && bytes[i] < 192) {\n          continue;\n        }\n      } else if (bytes[i] > 223 && bytes[i] < 240 && i + 2 < total_bytes) {\n        i++;\n\n        if (bytes[i] > 127 && bytes[i] < 192 && bytes[i + 1] > 127 && bytes[i + 1] < 192) {\n          i++;\n          continue;\n        }\n      }\n\n      suspicious_bytes++; // Read at least 32 bytes before making a decision\n\n      if (i > 32 && suspicious_bytes * 100 / total_bytes > 10) {\n        return true;\n      }\n    }\n  }\n\n  if (suspicious_bytes * 100 / total_bytes > 10) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/samianki/node_modules/pm2/lib/tools/isbinaryfile.js"],"names":["fs","require","max_bytes","module","exports","bytes","size","undefined","file","statSync","isFile","err","descriptor","openSync","Buffer","alloc","readSync","length","closeSync","callback","stat","open","read","close","err2","isBinaryCheck","suspicious_bytes","total_bytes","Math","min","i"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 the PM2 project authors. All rights reserved.\n * Use of this source code is governed by a license that\n * can be found in the LICENSE file.\n */\nvar fs = require('fs');\nvar max_bytes = 512;\n\nmodule.exports = function(bytes, size) {\n  // Read the file with no encoding for raw buffer access.\n  if (size === undefined) {\n    var file = bytes;\n    try {\n      if(!fs.statSync(file).isFile()) return false;\n    } catch (err) {\n      // otherwise continue on\n    }\n    var descriptor = fs.openSync(file, 'r');\n    try {\n      bytes = Buffer.alloc(max_bytes);\n      size = fs.readSync(descriptor, bytes, 0, bytes.length, 0);\n    } finally {\n      fs.closeSync(descriptor);\n    }\n  }\n  // async version has a function instead of a `size`\n  else if (typeof size === \"function\") {\n    var file = bytes, callback = size;\n    fs.stat(file, function(err, stat) {\n      if (err || !stat.isFile()) return callback(null, false);\n\n      fs.open(file, 'r', function(err, descriptor){\n        if (err) return callback(err);\n        var bytes = Buffer.alloc(max_bytes);\n        // Read the file with no encoding for raw buffer access.\n        fs.read(descriptor, bytes, 0, bytes.length, 0, function(err, size, bytes){\n          fs.close(descriptor, function(err2){\n            if (err || err2)\n              return callback(err || err2);\n            return callback(null, isBinaryCheck(bytes, size));\n          });\n        });\n      });\n    });\n  }\n\n  return isBinaryCheck(bytes, size);\n}\n\nfunction isBinaryCheck(bytes, size) {\n  if (size === 0)\n    return false;\n\n  var suspicious_bytes = 0;\n  var total_bytes = Math.min(size, max_bytes);\n\n  if (size >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) {\n    // UTF-8 BOM. This isn't binary.\n    return false;\n  }\n\n  for (var i = 0; i < total_bytes; i++) {\n    if (bytes[i] === 0) { // NULL byte--it's binary!\n      return true;\n    }\n    else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {\n      // UTF-8 detection\n      if (bytes[i] > 193 && bytes[i] < 224 && i + 1 < total_bytes) {\n        i++;\n        if (bytes[i] > 127 && bytes[i] < 192) {\n          continue;\n        }\n      }\n      else if (bytes[i] > 223 && bytes[i] < 240 && i + 2 < total_bytes) {\n        i++;\n        if (bytes[i] > 127 && bytes[i] < 192 && bytes[i + 1] > 127 && bytes[i + 1] < 192) {\n          i++;\n          continue;\n        }\n      }\n      suspicious_bytes++;\n      // Read at least 32 bytes before making a decision\n      if (i > 32 && (suspicious_bytes * 100) / total_bytes > 10) {\n        return true;\n      }\n    }\n  }\n\n  if ((suspicious_bytes * 100) / total_bytes > 10) {\n    return true;\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}