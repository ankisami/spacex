{"ast":null,"code":"'use strict';\n\nvar path = require('path'),\n    fs = require('fs');\n/**\n * Attempt to somewhat safely parse the JSON.\n *\n * @param {String} data JSON blob that needs to be parsed.\n * @returns {Object|false} Parsed JSON or false.\n * @api private\n */\n\n\nfunction parse(data) {\n  data = data.toString('utf-8'); //\n  // Remove a possible UTF-8 BOM (byte order marker) as this can lead to parse\n  // values when passed in to the JSON.parse.\n  //\n\n  if (data.charCodeAt(0) === 0xFEFF) data = data.slice(1);\n\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Find package.json files.\n *\n * @param {String|Object} root The root directory we should start searching in.\n * @returns {Object} Iterator interface.\n * @api public\n */\n\n\nmodule.exports = function find(root) {\n  root = root || process.cwd();\n\n  if (typeof root !== \"string\") {\n    if (typeof root === \"object\" && typeof root.filename === 'string') {\n      root = root.filename;\n    } else {\n      throw new Error(\"Must pass a filename string or a module object to finder\");\n    }\n  }\n\n  return {\n    /**\n     * Return the parsed package.json that we find in a parent folder.\n     *\n     * @returns {Object} Value, filename and indication if the iteration is done.\n     * @api public\n     */\n    next: function next() {\n      if (root.match(/^(\\w:\\\\|\\/)$/)) return {\n        value: undefined,\n        filename: undefined,\n        done: true\n      };\n      var file = path.join(root, 'package.json'),\n          data;\n      root = path.resolve(root, '..');\n\n      if (fs.existsSync(file) && (data = parse(fs.readFileSync(file)))) {\n        data.__path = file;\n        return {\n          value: data,\n          filename: file,\n          done: false\n        };\n      }\n\n      return next();\n    }\n  };\n};","map":{"version":3,"sources":["/Users/samianki/node_modules/pm2/lib/tools/find-package-json.js"],"names":["path","require","fs","parse","data","toString","charCodeAt","slice","JSON","e","module","exports","find","root","process","cwd","filename","Error","next","match","value","undefined","done","file","join","resolve","existsSync","readFileSync","__path"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;AAAA,IACIC,EAAE,GAAGD,OAAO,CAAC,IAAD,CADhB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,KAAT,CAAeC,IAAf,EAAqB;AACnBA,EAAAA,IAAI,GAAGA,IAAI,CAACC,QAAL,CAAc,OAAd,CAAP,CADmB,CAGnB;AACA;AACA;AACA;;AACA,MAAID,IAAI,CAACE,UAAL,CAAgB,CAAhB,MAAuB,MAA3B,EAAmCF,IAAI,GAAGA,IAAI,CAACG,KAAL,CAAW,CAAX,CAAP;;AAEnC,MAAI;AAAE,WAAOC,IAAI,CAACL,KAAL,CAAWC,IAAX,CAAP;AAA0B,GAAhC,CACA,OAAOK,CAAP,EAAU;AAAE,WAAO,KAAP;AAAe;AAC5B;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,IAAT,CAAcC,IAAd,EAAoB;AACnCA,EAAAA,IAAI,GAAGA,IAAI,IAAIC,OAAO,CAACC,GAAR,EAAf;;AACA,MAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAI,CAACG,QAAZ,KAAyB,QAAzD,EAAmE;AACjEH,MAAAA,IAAI,GAAGA,IAAI,CAACG,QAAZ;AACD,KAFD,MAEO;AACL,YAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;AACD;AACF;;AACD,SAAO;AACL;AACJ;AACA;AACA;AACA;AACA;AACIC,IAAAA,IAAI,EAAE,SAASA,IAAT,GAAgB;AACpB,UAAIL,IAAI,CAACM,KAAL,CAAW,cAAX,CAAJ,EAAgC,OAAO;AACrCC,QAAAA,KAAK,EAAEC,SAD8B;AAErCL,QAAAA,QAAQ,EAAEK,SAF2B;AAGrCC,QAAAA,IAAI,EAAE;AAH+B,OAAP;AAMhC,UAAIC,IAAI,GAAGvB,IAAI,CAACwB,IAAL,CAAUX,IAAV,EAAgB,cAAhB,CAAX;AAAA,UACIT,IADJ;AAGAS,MAAAA,IAAI,GAAGb,IAAI,CAACyB,OAAL,CAAaZ,IAAb,EAAmB,IAAnB,CAAP;;AAEA,UAAIX,EAAE,CAACwB,UAAH,CAAcH,IAAd,MAAwBnB,IAAI,GAAGD,KAAK,CAACD,EAAE,CAACyB,YAAH,CAAgBJ,IAAhB,CAAD,CAApC,CAAJ,EAAkE;AAChEnB,QAAAA,IAAI,CAACwB,MAAL,GAAcL,IAAd;AAEA,eAAO;AACLH,UAAAA,KAAK,EAAEhB,IADF;AAELY,UAAAA,QAAQ,EAAEO,IAFL;AAGLD,UAAAA,IAAI,EAAE;AAHD,SAAP;AAKD;;AAED,aAAOJ,IAAI,EAAX;AACD;AA9BI,GAAP;AAgCD,CAzCD","sourcesContent":["'use strict';\n\nvar path = require('path')\n  , fs = require('fs');\n\n/**\n * Attempt to somewhat safely parse the JSON.\n *\n * @param {String} data JSON blob that needs to be parsed.\n * @returns {Object|false} Parsed JSON or false.\n * @api private\n */\nfunction parse(data) {\n  data = data.toString('utf-8');\n\n  //\n  // Remove a possible UTF-8 BOM (byte order marker) as this can lead to parse\n  // values when passed in to the JSON.parse.\n  //\n  if (data.charCodeAt(0) === 0xFEFF) data = data.slice(1);\n\n  try { return JSON.parse(data); }\n  catch (e) { return false; }\n}\n\n/**\n * Find package.json files.\n *\n * @param {String|Object} root The root directory we should start searching in.\n * @returns {Object} Iterator interface.\n * @api public\n */\nmodule.exports = function find(root) {\n  root = root || process.cwd();\n  if (typeof root !== \"string\") {\n    if (typeof root === \"object\" && typeof root.filename === 'string') {\n      root = root.filename;\n    } else {\n      throw new Error(\"Must pass a filename string or a module object to finder\");\n    }\n  }\n  return {\n    /**\n     * Return the parsed package.json that we find in a parent folder.\n     *\n     * @returns {Object} Value, filename and indication if the iteration is done.\n     * @api public\n     */\n    next: function next() {\n      if (root.match(/^(\\w:\\\\|\\/)$/)) return {\n        value: undefined,\n        filename: undefined,\n        done: true\n      };\n\n      var file = path.join(root, 'package.json')\n        , data;\n\n      root = path.resolve(root, '..');\n\n      if (fs.existsSync(file) && (data = parse(fs.readFileSync(file)))) {\n        data.__path = file;\n\n        return {\n          value: data,\n          filename: file,\n          done: false\n        };\n      }\n\n      return next();\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}