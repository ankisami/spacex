{"ast":null,"code":"'use strict'; // @ts-check\n// ==================================================================================\n// filesystem.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 8. File System\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\n\nconst execSync = require('child_process').execSync;\n\nconst util = require('./util');\n\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = _platform === 'linux';\n\nconst _darwin = _platform === 'darwin';\n\nconst _windows = _platform === 'win32';\n\nconst _freebsd = _platform === 'freebsd';\n\nconst _openbsd = _platform === 'openbsd';\n\nconst _netbsd = _platform === 'netbsd';\n\nconst _sunos = _platform === 'sunos';\n\nconst NOT_SUPPORTED = 'not supported';\nlet _fs_speed = {};\nlet _disk_io = {}; // --------------------------\n// FS - mounted file systems\n\nfunction fsSize(callback) {\n  let macOsDisks = [];\n\n  function getmacOsFsType(fs) {\n    if (!fs.startsWith('/')) {\n      return 'NFS';\n    }\n\n    ;\n    const parts = fs.split('/');\n    const fsShort = parts[parts.length - 1];\n    const macOsDisksSingle = macOsDisks.filter(item => item.indexOf(fsShort) >= 0);\n\n    if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf('APFS') >= 0) {\n      return 'APFS';\n    }\n\n    return 'HFS';\n  }\n\n  function parseDf(lines) {\n    let data = [];\n    lines.forEach(function (line) {\n      if (line !== '') {\n        line = line.replace(/ +/g, ' ').split(' ');\n\n        if (line && (line[0].startsWith('/') || line[6] && line[6] === '/' || line[0].indexOf('/') > 0)) {\n          const fs = line[0];\n          const fstype = _linux || _freebsd || _openbsd || _netbsd ? line[1] : getmacOsFsType(line[0]);\n          const size = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1]) * 1024;\n          const used = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2]) * 1024;\n          const use = parseFloat((100.0 * (_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2]) / (_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1])).toFixed(2));\n          const mount = line[line.length - 1];\n\n          if (!data.find(el => el.fs === fs && el.type === fstype)) {\n            data.push({\n              fs,\n              type: fstype,\n              size,\n              used,\n              use,\n              mount\n            });\n          }\n        }\n      }\n    });\n    return data;\n  }\n\n  return new Promise(resolve => {\n    process.nextTick(() => {\n      let data = [];\n\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = '';\n\n        if (_darwin) {\n          cmd = 'df -kP';\n          macOsDisks = execSync('diskutil list').toString().split('\\n').filter(line => {\n            return !line.startsWith('/') && line.indexOf(':') > 0;\n          });\n        }\n\n        if (_linux) cmd = 'df -lkPTx squashfs | grep ^/';\n        if (_freebsd || _openbsd || _netbsd) cmd = 'df -lkPT';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            data = parseDf(lines);\n\n            if (callback) {\n              callback(data);\n            }\n\n            resolve(data);\n          } else {\n            exec('df -kPT', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                data = parseDf(lines);\n              }\n\n              if (callback) {\n                callback(data);\n              }\n\n              resolve(data);\n            });\n          }\n        });\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(data);\n        }\n\n        resolve(data);\n      }\n\n      if (_windows) {\n        try {\n          util.wmic('logicaldisk get Caption,FileSystem,FreeSpace,Size').then(stdout => {\n            let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n            lines.forEach(function (line) {\n              if (line !== '') {\n                line = line.trim().split(/\\s\\s+/);\n                data.push({\n                  'fs': line[0],\n                  'type': line[1],\n                  'size': parseInt(line[3]),\n                  'used': parseInt(line[3]) - parseInt(line[2]),\n                  'use': parseFloat(100.0 * (parseInt(line[3]) - parseInt(line[2])) / parseInt(line[3])),\n                  'mount': line[0]\n                });\n              }\n            });\n\n            if (callback) {\n              callback(data);\n            }\n\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) {\n            callback(data);\n          }\n\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.fsSize = fsSize; // --------------------------\n// FS - open files count\n\nfunction fsOpenFiles(callback) {\n  return new Promise(resolve => {\n    process.nextTick(() => {\n      const result = {\n        max: -1,\n        allocated: -1,\n        available: -1\n      };\n\n      if (_freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = 'sysctl -a | grep \\'kern.*files\\'';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result.max = parseInt(util.getValue(lines, 'kern.maxfiles', ':'), 10);\n            result.allocated = parseInt(util.getValue(lines, 'kern.num_files', ':'), 10);\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_linux) {\n        fs.readFile('/proc/sys/fs/file-nr', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n\n            if (lines[0]) {\n              const parts = lines[0].replace(/\\s+/g, ' ').split(' ');\n\n              if (parts.length === 3) {\n                result.allocated = parseInt(parts[0], 10);\n                result.available = parseInt(parts[1], 10);\n                result.max = parseInt(parts[2], 10);\n              }\n            }\n          }\n\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        });\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_windows) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsOpenFiles = fsOpenFiles; // --------------------------\n// disks\n\nfunction parseBytes(s) {\n  return parseInt(s.substr(s.indexOf(' (') + 2, s.indexOf(' Bytes)') - 10));\n}\n\nfunction parseDevices(lines) {\n  let devices = [];\n  let i = 0;\n  lines.forEach(line => {\n    if (line.length > 0) {\n      if (line[0] === '*') {\n        i++;\n      } else {\n        let parts = line.split(':');\n\n        if (parts.length > 1) {\n          if (!devices[i]) devices[i] = {\n            name: '',\n            identifier: '',\n            type: 'disk',\n            fstype: '',\n            mount: '',\n            size: 0,\n            physical: 'HDD',\n            uuid: '',\n            label: '',\n            model: '',\n            serial: '',\n            removable: false,\n            protocol: ''\n          };\n          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, '');\n          parts[1] = parts[1].trim();\n          if ('DEVICEIDENTIFIER' === parts[0]) devices[i].identifier = parts[1];\n          if ('DEVICENODE' === parts[0]) devices[i].name = parts[1];\n\n          if ('VOLUMENAME' === parts[0]) {\n            if (parts[1].indexOf('Not applicable') === -1) devices[i].label = parts[1];\n          }\n\n          if ('PROTOCOL' === parts[0]) devices[i].protocol = parts[1];\n          if ('DISKSIZE' === parts[0]) devices[i].size = parseBytes(parts[1]);\n          if ('FILESYSTEMPERSONALITY' === parts[0]) devices[i].fstype = parts[1];\n          if ('MOUNTPOINT' === parts[0]) devices[i].mount = parts[1];\n          if ('VOLUMEUUID' === parts[0]) devices[i].uuid = parts[1];\n          if ('READ-ONLYMEDIA' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'CD/DVD';\n          if ('SOLIDSTATE' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'SSD';\n          if ('VIRTUAL' === parts[0]) devices[i].type = 'virtual';\n          if ('REMOVABLEMEDIA' === parts[0]) devices[i].removable = parts[1] === 'Removable';\n          if ('PARTITIONTYPE' === parts[0]) devices[i].type = 'part';\n          if ('DEVICE/MEDIANAME' === parts[0]) devices[i].model = parts[1];\n        }\n      }\n    }\n  });\n  return devices;\n}\n\nfunction parseBlk(lines) {\n  let data = [];\n  lines.filter(line => line !== '').forEach(line => {\n    try {\n      line = decodeURIComponent(line.replace(/\\\\x/g, '%'));\n      line = line.replace(/\\\\/g, '\\\\\\\\');\n      let disk = JSON.parse(line);\n      data.push({\n        'name': disk.name,\n        'type': disk.type,\n        'fstype': disk.fstype,\n        'mount': disk.mountpoint,\n        'size': parseInt(disk.size),\n        'physical': disk.type === 'disk' ? disk.rota === '0' ? 'SSD' : 'HDD' : disk.type === 'rom' ? 'CD/DVD' : '',\n        'uuid': disk.uuid,\n        'label': disk.label,\n        'model': disk.model,\n        'serial': disk.serial,\n        'removable': disk.rm === '1',\n        'protocol': disk.tran,\n        'group': disk.group\n      });\n    } catch (e) {\n      util.noop();\n    }\n  });\n  data = util.unique(data);\n  data = util.sortByKey(data, ['type', 'name']);\n  return data;\n}\n\nfunction blkStdoutToObject(stdout) {\n  return stdout.toString().replace(/NAME=/g, '{\"name\":').replace(/FSTYPE=/g, ',\"fstype\":').replace(/TYPE=/g, ',\"type\":').replace(/SIZE=/g, ',\"size\":').replace(/MOUNTPOINT=/g, ',\"mountpoint\":').replace(/UUID=/g, ',\"uuid\":').replace(/ROTA=/g, ',\"rota\":').replace(/RO=/g, ',\"ro\":').replace(/RM=/g, ',\"rm\":').replace(/TRAN=/g, ',\"tran\":').replace(/SERIAL=/g, ',\"serial\":').replace(/LABEL=/g, ',\"label\":').replace(/MODEL=/g, ',\"model\":').replace(/OWNER=/g, ',\"owner\":').replace(/GROUP=/g, ',\"group\":').replace(/\\n/g, '}\\n');\n}\n\nfunction blockDevices(callback) {\n  return new Promise(resolve => {\n    process.nextTick(() => {\n      let data = [];\n\n      if (_linux) {\n        // see https://wiki.ubuntuusers.de/lsblk/\n        // exec(\"lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME\", function (error, stdout) {\n        exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null', function (error, stdout) {\n          if (!error) {\n            let lines = blkStdoutToObject(stdout).split('\\n');\n            data = parseBlk(lines);\n\n            if (callback) {\n              callback(data);\n            }\n\n            resolve(data);\n          } else {\n            exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null', function (error, stdout) {\n              if (!error) {\n                let lines = blkStdoutToObject(stdout).split('\\n');\n                data = parseBlk(lines);\n              }\n\n              if (callback) {\n                callback(data);\n              }\n\n              resolve(data);\n            });\n          }\n        });\n      }\n\n      if (_darwin) {\n        exec('diskutil info -all', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n'); // parse lines into temp array of devices\n\n            data = parseDevices(lines);\n          }\n\n          if (callback) {\n            callback(data);\n          }\n\n          resolve(data);\n        });\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(data);\n        }\n\n        resolve(data);\n      }\n\n      if (_windows) {\n        let drivetypes = ['Unknown', 'NoRoot', 'Removable', 'Local', 'Network', 'CD/DVD', 'RAM'];\n\n        try {\n          util.wmic('logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /value').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                let drivetype = util.getValue(lines, 'drivetype', '=');\n\n                if (drivetype) {\n                  data.push({\n                    name: util.getValue(lines, 'name', '='),\n                    identifier: util.getValue(lines, 'caption', '='),\n                    type: 'disk',\n                    fstype: util.getValue(lines, 'filesystem', '=').toLowerCase(),\n                    mount: util.getValue(lines, 'caption', '='),\n                    size: util.getValue(lines, 'size', '='),\n                    physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],\n                    uuid: util.getValue(lines, 'volumeserialnumber', '='),\n                    label: util.getValue(lines, 'volumename', '='),\n                    model: '',\n                    serial: util.getValue(lines, 'volumeserialnumber', '='),\n                    removable: drivetype === '2',\n                    protocol: ''\n                  });\n                }\n              });\n            }\n\n            if (callback) {\n              callback(data);\n            }\n\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) {\n            callback(data);\n          }\n\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.blockDevices = blockDevices; // --------------------------\n// FS - speed\n\nfunction calcFsSpeed(rx, wx) {\n  let result = {\n    rx: 0,\n    wx: 0,\n    tx: 0,\n    rx_sec: -1,\n    wx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_fs_speed && _fs_speed.ms) {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    result.ms = Date.now() - _fs_speed.ms;\n    result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);\n    result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);\n    result.tx_sec = result.rx_sec + result.wx_sec;\n    _fs_speed.rx_sec = result.rx_sec;\n    _fs_speed.wx_sec = result.wx_sec;\n    _fs_speed.tx_sec = result.tx_sec;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    _fs_speed.rx_sec = -1;\n    _fs_speed.wx_sec = -1;\n    _fs_speed.tx_sec = -1;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = 0;\n  }\n\n  return result;\n}\n\nfunction fsStats(callback) {\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n\n        reject(error);\n      }\n\n      let result = {\n        rx: 0,\n        wx: 0,\n        tx: 0,\n        rx_sec: -1,\n        wx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n      let rx = 0;\n      let wx = 0;\n\n      if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {\n        if (_linux) {\n          // exec(\"df -k | grep /dev/\", function(error, stdout) {\n          exec('lsblk 2>/dev/null | grep /', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              let fs_filter = [];\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.replace(/[├─│└]+/g, '').trim().split(' ');\n                  if (fs_filter.indexOf(line[0]) === -1) fs_filter.push(line[0]);\n                }\n              });\n              let output = fs_filter.join('|');\n              exec('cat /proc/diskstats | egrep \"' + output + '\"', function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.forEach(function (line) {\n                    line = line.trim();\n\n                    if (line !== '') {\n                      line = line.replace(/ +/g, ' ').split(' ');\n                      rx += parseInt(line[5]) * 512;\n                      wx += parseInt(line[9]) * 512;\n                    }\n                  });\n                  result = calcFsSpeed(rx, wx);\n                }\n\n                if (callback) {\n                  callback(result);\n                }\n\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }\n          });\n        }\n\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n\n                if (line !== '') {\n                  line = line.split(',');\n                  rx += parseInt(line[2]);\n                  wx += parseInt(line[9]);\n                }\n              });\n              result = calcFsSpeed(rx, wx);\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          });\n        }\n      } else {\n        result.ms = _fs_speed.last_ms;\n        result.rx = _fs_speed.bytes_read;\n        result.wx = _fs_speed.bytes_write;\n        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;\n        result.rx_sec = _fs_speed.rx_sec;\n        result.wx_sec = _fs_speed.wx_sec;\n        result.tx_sec = _fs_speed.tx_sec;\n\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsStats = fsStats;\n\nfunction calcDiskIO(rIO, wIO) {\n  let result = {\n    rIO: 0,\n    wIO: 0,\n    tIO: 0,\n    rIO_sec: -1,\n    wIO_sec: -1,\n    tIO_sec: -1,\n    ms: 0\n  };\n\n  if (_disk_io && _disk_io.ms) {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.ms = Date.now() - _disk_io.ms;\n    result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);\n    result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);\n    result.tIO_sec = result.rIO_sec + result.wIO_sec;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = result.rIO_sec;\n    _disk_io.wIO_sec = result.wIO_sec;\n    _disk_io.tIO_sec = result.tIO_sec;\n    _disk_io.last_ms = result.ms;\n    _disk_io.ms = Date.now();\n  } else {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = -1;\n    _disk_io.wIO_sec = -1;\n    _disk_io.tIO_sec = -1;\n    _disk_io.last_ms = 0;\n    _disk_io.ms = Date.now();\n  }\n\n  return result;\n}\n\nfunction disksIO(callback) {\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n\n        reject(error);\n      }\n\n      if (_sunos) {\n        let error = new Error(NOT_SUPPORTED);\n\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n\n        reject(error);\n      }\n\n      let result = {\n        rIO: 0,\n        wIO: 0,\n        tIO: 0,\n        rIO_sec: -1,\n        wIO_sec: -1,\n        tIO_sec: -1,\n        ms: 0\n      };\n      let rIO = 0;\n      let wIO = 0;\n\n      if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {\n        if (_linux || _freebsd || _openbsd || _netbsd) {\n          // prints Block layer statistics for all mounted volumes\n          // var cmd = \"for mount in `lsblk | grep / | sed -r 's/│ └─//' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          // var cmd = \"for mount in `lsblk | grep / | sed 's/[│└─├]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          let cmd = 'for mount in `lsblk 2>/dev/null | grep \" disk \" | sed \"s/[│└─├]//g\" | awk \\'{$1=$1};1\\' | cut -d \" \" -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r \"s/ +/;/g\" | sed -r \"s/^;//\"; done';\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.split('\\n');\n              lines.forEach(function (line) {\n                // ignore empty lines\n                if (!line) return; // sum r/wIO of all disks to compute all disks IO\n\n                let stats = line.split(';');\n                rIO += parseInt(stats[0]);\n                wIO += parseInt(stats[4]);\n              });\n              result = calcDiskIO(rIO, wIO);\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }\n          });\n        }\n\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n\n                if (line !== '') {\n                  line = line.split(',');\n                  rIO += parseInt(line[10]);\n                  wIO += parseInt(line[0]);\n                }\n              });\n              result = calcDiskIO(rIO, wIO);\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          });\n        }\n      } else {\n        result.rIO = _disk_io.rIO;\n        result.wIO = _disk_io.wIO;\n        result.tIO = _disk_io.rIO + _disk_io.wIO;\n        result.ms = _disk_io.last_ms;\n        result.rIO_sec = _disk_io.rIO_sec;\n        result.wIO_sec = _disk_io.wIO_sec;\n        result.tIO_sec = _disk_io.tIO_sec;\n\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.disksIO = disksIO;\n\nfunction diskLayout(callback) {\n  function getVendorFromModel(model) {\n    const diskManufacturers = [{\n      pattern: '^WESTERN.+',\n      manufacturer: 'Western Digital'\n    }, {\n      pattern: '^WDC.+',\n      manufacturer: 'Western Digital'\n    }, {\n      pattern: 'WD.+',\n      manufacturer: 'Western Digital'\n    }, {\n      pattern: '^TOSHIBA.+',\n      manufacturer: 'Toshiba'\n    }, {\n      pattern: '^HITACHI.+',\n      manufacturer: 'Hitachi'\n    }, {\n      pattern: '^IC.+',\n      manufacturer: 'Hitachi'\n    }, {\n      pattern: '^HTS.+',\n      manufacturer: 'Hitachi'\n    }, {\n      pattern: '^SANDISK.+',\n      manufacturer: 'SanDisk'\n    }, {\n      pattern: '^KINGSTON.+',\n      manufacturer: 'Kingston Technonogy'\n    }, {\n      pattern: '^SONY.+',\n      manufacturer: 'Sony'\n    }, {\n      pattern: '^TRANSCEND.+',\n      manufacturer: 'Transcend'\n    }, {\n      pattern: 'SAMSUNG.+',\n      manufacturer: 'Samsung'\n    }, {\n      pattern: '^ST(?!I\\\\ ).+',\n      manufacturer: 'Seagate'\n    }, {\n      pattern: '^STI\\\\ .+',\n      manufacturer: 'SimpleTech'\n    }, {\n      pattern: '^D...-.+',\n      manufacturer: 'IBM'\n    }, {\n      pattern: '^IBM.+',\n      manufacturer: 'IBM'\n    }, {\n      pattern: '^FUJITSU.+',\n      manufacturer: 'Fujitsu'\n    }, {\n      pattern: '^MP.+',\n      manufacturer: 'Fujitsu'\n    }, {\n      pattern: '^MK.+',\n      manufacturer: 'Toshiba'\n    }, {\n      pattern: '^MAXTOR.+',\n      manufacturer: 'Maxtor'\n    }, {\n      pattern: '^Pioneer.+',\n      manufacturer: 'Pioneer'\n    }, {\n      pattern: '^PHILIPS.+',\n      manufacturer: 'Philips'\n    }, {\n      pattern: '^QUANTUM.+',\n      manufacturer: 'Quantum Technology'\n    }, {\n      pattern: 'FIREBALL.+',\n      manufacturer: 'Quantum Technology'\n    }, {\n      pattern: '^VBOX.+',\n      manufacturer: 'VirtualBox'\n    }, {\n      pattern: 'CORSAIR.+',\n      manufacturer: 'Corsair Components'\n    }, {\n      pattern: 'CRUCIAL.+',\n      manufacturer: 'Crucial'\n    }, {\n      pattern: 'ECM.+',\n      manufacturer: 'ECM'\n    }, {\n      pattern: 'INTEL.+',\n      manufacturer: 'INTEL'\n    }];\n    let result = '';\n\n    if (model) {\n      model = model.toUpperCase();\n      diskManufacturers.forEach(manufacturer => {\n        const re = RegExp(manufacturer.pattern);\n\n        if (re.test(model)) {\n          result = manufacturer.manufacturer;\n        }\n      });\n    }\n\n    return result;\n  }\n\n  return new Promise(resolve => {\n    process.nextTick(() => {\n      const commitResult = res => {\n        for (let i = 0; i < res.length; i++) {\n          delete res[i].BSDName;\n        }\n\n        if (callback) {\n          callback(res);\n        }\n\n        resolve(res);\n      };\n\n      let result = [];\n      let cmd = '';\n\n      if (_linux) {\n        let cmdFullSmart = '';\n        exec('export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            try {\n              const out = stdout.toString().trim();\n              let devices = [];\n\n              try {\n                const outJSON = JSON.parse(out);\n\n                if (outJSON && {}.hasOwnProperty.call(outJSON, 'blockdevices')) {\n                  devices = outJSON.blockdevices.filter(item => {\n                    return (item.group === 'disk' || item.type === 'disk') && item.size > 0 && (item.model !== null || item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null);\n                  });\n                }\n              } catch (e) {\n                // fallback to older version of lsblk\n                const out2 = execSync('export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL').toString();\n                let lines = blkStdoutToObject(out2).split('\\n');\n                const data = parseBlk(lines);\n                devices = data.filter(item => {\n                  return (item.group === 'disk' || item.type === 'disk') && item.size > 0 && (item.model !== null && item.model !== '' || item.mountpoint === '' && item.label === '' && item.fstype === '');\n                });\n              }\n\n              devices.forEach(device => {\n                let mediumType = '';\n                const BSDName = '/dev/' + device.name;\n                const logical = device.name;\n\n                try {\n                  mediumType = execSync('cat /sys/block/' + logical + '/queue/rotational 2>/dev/null').toString().split('\\n')[0];\n                } catch (e) {\n                  util.noop();\n                }\n\n                let interfaceType = device.tran ? device.tran.toUpperCase().trim() : '';\n\n                if (interfaceType === 'NVME') {\n                  mediumType = '2';\n                  interfaceType = 'PCIe';\n                }\n\n                result.push({\n                  device: BSDName,\n                  type: mediumType === '0' ? 'SSD' : mediumType === '1' ? 'HD' : mediumType === '2' ? 'NVMe' : device.model && device.model.indexOf('SSD') > -1 ? 'SSD' : device.model && device.model.indexOf('NVM') > -1 ? 'NVMe' : 'HD',\n                  name: device.model || '',\n                  vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ''),\n                  size: device.size || 0,\n                  bytesPerSector: -1,\n                  totalCylinders: -1,\n                  totalHeads: -1,\n                  totalSectors: -1,\n                  totalTracks: -1,\n                  tracksPerCylinder: -1,\n                  sectorsPerTrack: -1,\n                  firmwareRevision: device.rev ? device.rev.trim() : '',\n                  serialNum: device.serial ? device.serial.trim() : '',\n                  interfaceType: interfaceType,\n                  smartStatus: 'unknown',\n                  BSDName: BSDName\n                });\n                cmd += `printf \"\\n${BSDName}|\"; smartctl -H ${BSDName} | grep overall;`;\n                cmdFullSmart += `${cmdFullSmart ? 'printf \",\";' : ''}smartctl -a -j ${BSDName};`;\n              });\n            } catch (e) {\n              util.noop();\n            }\n          } // check S.M.A.R.T. status\n\n\n          if (cmdFullSmart) {\n            exec(cmdFullSmart, function (error, stdout) {\n              try {\n                const data = JSON.parse(`[${stdout}]`);\n                data.forEach(disk => {\n                  const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];\n\n                  for (let i = 0; i < result.length; i++) {\n                    if (result[i].BSDName === diskBSDName) {\n                      result[i].smartStatus = disk.smart_status.passed ? 'Ok' : disk.smart_status.passed === false ? 'Predicted Failure' : 'unknown';\n                      result[i].smartData = disk;\n                    }\n                  }\n                });\n                commitResult(result);\n              } catch (e) {\n                if (cmd) {\n                  cmd = cmd + 'printf \"\\n\"';\n                  exec(cmd, function (error, stdout) {\n                    let lines = stdout.toString().split('\\n');\n                    lines.forEach(line => {\n                      if (line) {\n                        let parts = line.split('|');\n\n                        if (parts.length === 2) {\n                          let BSDName = parts[0];\n                          parts[1] = parts[1].trim();\n                          let parts2 = parts[1].split(':');\n\n                          if (parts2.length === 2) {\n                            parts2[1] = parts2[1].trim();\n                            let status = parts2[1].toLowerCase();\n\n                            for (let i = 0; i < result.length; i++) {\n                              if (result[i].BSDName === BSDName) {\n                                result[i].smartStatus = status === 'passed' ? 'Ok' : status === 'failed!' ? 'Predicted Failure' : 'unknown';\n                              }\n                            }\n                          }\n                        }\n                      }\n                    });\n                    commitResult(result);\n                  });\n                } else {\n                  commitResult(result);\n                }\n              }\n            });\n          } else {\n            commitResult(result);\n          }\n        });\n      }\n\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_sunos) {\n        if (callback) {\n          callback(result);\n        }\n\n        resolve(result);\n      }\n\n      if (_darwin) {\n        exec('system_profiler SPSerialATADataType SPNVMeDataType', function (error, stdout) {\n          if (!error) {\n            let parts = stdout.toString().split('NVMExpress:');\n            let devices = parts[0].split(' Physical Interconnect: ');\n            devices.shift();\n            devices.forEach(function (device) {\n              device = 'InterfaceType: ' + device;\n              let lines = device.split('\\n');\n              const mediumType = util.getValue(lines, 'Medium Type', ':', true).trim();\n              const sizeStr = util.getValue(lines, 'capacity', ':', true).trim();\n              const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n\n              if (sizeStr) {\n                let sizeValue = 0;\n\n                if (sizeStr.indexOf('(') >= 0) {\n                  sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, ''));\n                }\n\n                if (!sizeValue) {\n                  sizeValue = parseInt(sizeStr);\n                }\n\n                if (sizeValue) {\n                  result.push({\n                    device: BSDName,\n                    type: mediumType.startsWith('Solid') ? 'SSD' : 'HD',\n                    name: util.getValue(lines, 'Model', ':', true).trim(),\n                    vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                    size: sizeValue,\n                    bytesPerSector: -1,\n                    totalCylinders: -1,\n                    totalHeads: -1,\n                    totalSectors: -1,\n                    totalTracks: -1,\n                    tracksPerCylinder: -1,\n                    sectorsPerTrack: -1,\n                    firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                    serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                    interfaceType: util.getValue(lines, 'InterfaceType', ':', true).trim(),\n                    smartStatus: 'unknown',\n                    BSDName: BSDName\n                  });\n                  cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                }\n              }\n            });\n\n            if (parts.length > 1) {\n              let devices = parts[1].split('\\n\\n          Capacity:');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = '!Capacity: ' + device;\n                let lines = device.split('\\n');\n                const linkWidth = util.getValue(lines, 'link width', ':', true).trim();\n                const sizeStr = util.getValue(lines, '!capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n\n                if (sizeStr) {\n                  let sizeValue = 0;\n\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, ''));\n                  }\n\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n\n                  if (sizeValue) {\n                    result.push({\n                      device: BSDName,\n                      type: 'NVMe',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: -1,\n                      totalCylinders: -1,\n                      totalHeads: -1,\n                      totalSectors: -1,\n                      totalTracks: -1,\n                      tracksPerCylinder: -1,\n                      sectorsPerTrack: -1,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: ('PCIe ' + linkWidth).trim(),\n                      smartStatus: 'unknown',\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            }\n          }\n\n          if (cmd) {\n            cmd = cmd + 'printf \"\\n\"';\n            exec(cmd, function (error, stdout) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(line => {\n                if (line) {\n                  let parts = line.split('|');\n\n                  if (parts.length === 2) {\n                    let BSDName = parts[0];\n                    parts[1] = parts[1].trim();\n                    let parts2 = parts[1].split(':');\n\n                    if (parts2.length === 2) {\n                      parts2[1] = parts2[1].trim();\n                      let status = parts2[1].toLowerCase();\n\n                      for (let i = 0; i < result.length; i++) {\n                        if (result[i].BSDName === BSDName) {\n                          result[i].smartStatus = status === 'not supported' ? 'not supported' : status === 'verified' ? 'Ok' : status === 'failing' ? 'Predicted Failure' : 'unknown';\n                        }\n                      }\n                    }\n                  }\n                }\n              });\n\n              for (let i = 0; i < result.length; i++) {\n                delete result[i].BSDName;\n              }\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          } else {\n            for (let i = 0; i < result.length; i++) {\n              delete result[i].BSDName;\n            }\n\n            if (callback) {\n              callback(result);\n            }\n\n            resolve(result);\n          }\n        });\n      }\n\n      if (_windows) {\n        try {\n          util.wmic('diskdrive get /value').then((stdout, error) => {\n            let devices = stdout.toString().split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const size = util.getValue(lines, 'Size', '=').trim();\n              const status = util.getValue(lines, 'Status', '=').trim().toLowerCase();\n\n              if (size) {\n                result.push({\n                  device: '',\n                  type: device.indexOf('SSD') > -1 ? 'SSD' : 'HD',\n                  // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below\n                  name: util.getValue(lines, 'Caption', '='),\n                  vendor: util.getValue(lines, 'Manufacturer', '='),\n                  size: parseInt(size),\n                  bytesPerSector: parseInt(util.getValue(lines, 'BytesPerSector', '=')),\n                  totalCylinders: parseInt(util.getValue(lines, 'TotalCylinders', '=')),\n                  totalHeads: parseInt(util.getValue(lines, 'TotalHeads', '=')),\n                  totalSectors: parseInt(util.getValue(lines, 'TotalSectors', '=')),\n                  totalTracks: parseInt(util.getValue(lines, 'TotalTracks', '=')),\n                  tracksPerCylinder: parseInt(util.getValue(lines, 'TracksPerCylinder', '=')),\n                  sectorsPerTrack: parseInt(util.getValue(lines, 'SectorsPerTrack', '=')),\n                  firmwareRevision: util.getValue(lines, 'FirmwareRevision', '=').trim(),\n                  serialNum: util.getValue(lines, 'SerialNumber', '=').trim(),\n                  interfaceType: util.getValue(lines, 'InterfaceType', '=').trim(),\n                  smartStatus: status === 'ok' ? 'Ok' : status === 'degraded' ? 'Degraded' : status === 'pred fail' ? 'Predicted Failure' : 'Unknown'\n                });\n              }\n            });\n            util.powerShell('Get-PhysicalDisk | Format-List').then(data => {\n              let devices = data.split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                const serialNum = util.getValue(lines, 'SerialNumber', ':').trim();\n                const name = util.getValue(lines, 'FriendlyName', ':').trim().replace('Msft ', 'Microsoft');\n                const size = util.getValue(lines, 'Size', ':').trim();\n                const model = util.getValue(lines, 'Model', ':').trim();\n                const interfaceType = util.getValue(lines, 'BusType', ':').trim();\n                let mediaType = util.getValue(lines, 'MediaType', ':').trim();\n\n                if (mediaType === '3' || mediaType === 'HDD') {\n                  mediaType = 'HD';\n                }\n\n                if (mediaType === '4') {\n                  mediaType = 'SSD';\n                }\n\n                if (mediaType === '5') {\n                  mediaType = 'SCM';\n                }\n\n                if (mediaType === 'Unspecified' && (model.toLowerCase().indexOf('virtual') > -1 || model.toLowerCase().indexOf('vbox') > -1)) {\n                  mediaType = 'Virtual';\n                }\n\n                if (size) {\n                  let i = util.findObjectByKey(result, 'serialNum', serialNum);\n\n                  if (i === -1 || serialNum === '') {\n                    i = util.findObjectByKey(result, 'name', name);\n                  }\n\n                  if (i != -1) {\n                    result[i].type = mediaType;\n                    result[i].interfaceType = interfaceType;\n                  }\n                }\n              });\n\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            }).catch(() => {\n              if (callback) {\n                callback(result);\n              }\n\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) {\n            callback(result);\n          }\n\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.diskLayout = diskLayout;","map":{"version":3,"sources":["/Users/samianki/node_modules/systeminformation/lib/filesystem.js"],"names":["exec","require","execSync","util","fs","_platform","process","platform","_linux","_darwin","_windows","_freebsd","_openbsd","_netbsd","_sunos","NOT_SUPPORTED","_fs_speed","_disk_io","fsSize","callback","macOsDisks","getmacOsFsType","startsWith","parts","split","fsShort","length","macOsDisksSingle","filter","item","indexOf","parseDf","lines","data","forEach","line","replace","fstype","size","parseInt","used","use","parseFloat","toFixed","mount","find","el","type","push","Promise","resolve","nextTick","cmd","toString","error","stdout","wmic","then","trim","idx","e","exports","fsOpenFiles","result","max","allocated","available","getValue","readFile","parseBytes","s","substr","parseDevices","devices","i","name","identifier","physical","uuid","label","model","serial","removable","protocol","toUpperCase","parseBlk","decodeURIComponent","disk","JSON","parse","mountpoint","rota","rm","tran","group","noop","unique","sortByKey","blkStdoutToObject","blockDevices","drivetypes","device","drivetype","toLowerCase","calcFsSpeed","rx","wx","tx","rx_sec","wx_sec","tx_sec","ms","Date","now","bytes_read","bytes_write","bytes_overall","last_ms","fsStats","reject","Error","fs_filter","output","join","calcDiskIO","rIO","wIO","tIO","rIO_sec","wIO_sec","tIO_sec","disksIO","stats","diskLayout","getVendorFromModel","diskManufacturers","pattern","manufacturer","re","RegExp","test","commitResult","res","BSDName","cmdFullSmart","out","outJSON","hasOwnProperty","call","blockdevices","parttype","out2","mediumType","logical","interfaceType","vendor","bytesPerSector","totalCylinders","totalHeads","totalSectors","totalTracks","tracksPerCylinder","sectorsPerTrack","firmwareRevision","rev","serialNum","smartStatus","diskBSDName","smartctl","argv","smart_status","passed","smartData","parts2","status","shift","sizeStr","sizeValue","match","linkWidth","powerShell","mediaType","findObjectByKey","catch"],"mappings":"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","sourcesContent":["'use strict';\n// @ts-check\n// ==================================================================================\n// filesystem.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 8. File System\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst NOT_SUPPORTED = 'not supported';\n\nlet _fs_speed = {};\nlet _disk_io = {};\n\n// --------------------------\n// FS - mounted file systems\n\nfunction fsSize(callback) {\n\n  let macOsDisks = [];\n\n  function getmacOsFsType(fs) {\n    if (!fs.startsWith('/')) { return 'NFS' };\n    const parts = fs.split('/');\n    const fsShort = parts[parts.length - 1];\n    const macOsDisksSingle = macOsDisks.filter(item => item.indexOf(fsShort) >= 0)\n    if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf('APFS') >= 0) { return 'APFS' }\n    return 'HFS';\n  }\n\n  function parseDf(lines) {\n    let data = [];\n    lines.forEach(function (line) {\n      if (line !== '') {\n        line = line.replace(/ +/g, ' ').split(' ');\n        if (line && ((line[0].startsWith('/')) || (line[6] && line[6] === '/') || (line[0].indexOf('/') > 0))) {\n          const fs = line[0];\n          const fstype = ((_linux || _freebsd || _openbsd || _netbsd) ? line[1] : getmacOsFsType(line[0]));\n          const size = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[2] : line[1])) * 1024;\n          const used = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[3] : line[2])) * 1024;\n          const use = parseFloat((100.0 * ((_linux || _freebsd || _openbsd || _netbsd) ? line[3] : line[2]) / ((_linux || _freebsd || _openbsd || _netbsd) ? line[2] : line[1])).toFixed(2));\n          const mount = line[line.length - 1];\n          if (!data.find(el => (el.fs === fs && el.type === fstype))) {\n            data.push({\n              fs,\n              type: fstype,\n              size,\n              used,\n              use,\n              mount\n            });\n          }\n        }\n      }\n    });\n    return data;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = '';\n        if (_darwin) {\n          cmd = 'df -kP';\n          macOsDisks = execSync('diskutil list').toString().split('\\n').filter(line => {\n            return !line.startsWith('/') && line.indexOf(':') > 0\n          });\n        }\n        if (_linux) cmd = 'df -lkPTx squashfs | grep ^/';\n        if (_freebsd || _openbsd || _netbsd) cmd = 'df -lkPT';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            data = parseDf(lines);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('df -kPT', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                data = parseDf(lines);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        try {\n          util.wmic('logicaldisk get Caption,FileSystem,FreeSpace,Size').then((stdout) => {\n            let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n            lines.forEach(function (line) {\n              if (line !== '') {\n                line = line.trim().split(/\\s\\s+/);\n                data.push({\n                  'fs': line[0],\n                  'type': line[1],\n                  'size': parseInt(line[3]),\n                  'used': parseInt(line[3]) - parseInt(line[2]),\n                  'use': parseFloat((100.0 * (parseInt(line[3]) - parseInt(line[2]))) / parseInt(line[3])),\n                  'mount': line[0]\n                });\n              }\n            });\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.fsSize = fsSize;\n\n// --------------------------\n// FS - open files count\n\nfunction fsOpenFiles(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = {\n        max: -1,\n        allocated: -1,\n        available: -1\n      };\n      if (_freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = 'sysctl -a | grep \\'kern.*files\\'';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result.max = parseInt(util.getValue(lines, 'kern.maxfiles', ':'), 10);\n            result.allocated = parseInt(util.getValue(lines, 'kern.num_files', ':'), 10);\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        fs.readFile('/proc/sys/fs/file-nr', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines[0]) {\n              const parts = lines[0].replace(/\\s+/g, ' ').split(' ');\n              if (parts.length === 3) {\n                result.allocated = parseInt(parts[0], 10);\n                result.available = parseInt(parts[1], 10);\n                result.max = parseInt(parts[2], 10);\n              }\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsOpenFiles = fsOpenFiles;\n\n// --------------------------\n// disks\n\nfunction parseBytes(s) {\n  return parseInt(s.substr(s.indexOf(' (') + 2, s.indexOf(' Bytes)') - 10));\n}\n\nfunction parseDevices(lines) {\n  let devices = [];\n  let i = 0;\n  lines.forEach(line => {\n    if (line.length > 0) {\n      if (line[0] === '*') {\n        i++;\n      } else {\n        let parts = line.split(':');\n        if (parts.length > 1) {\n          if (!devices[i]) devices[i] = {\n            name: '',\n            identifier: '',\n            type: 'disk',\n            fstype: '',\n            mount: '',\n            size: 0,\n            physical: 'HDD',\n            uuid: '',\n            label: '',\n            model: '',\n            serial: '',\n            removable: false,\n            protocol: ''\n          };\n          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, '');\n          parts[1] = parts[1].trim();\n          if ('DEVICEIDENTIFIER' === parts[0]) devices[i].identifier = parts[1];\n          if ('DEVICENODE' === parts[0]) devices[i].name = parts[1];\n          if ('VOLUMENAME' === parts[0]) {\n            if (parts[1].indexOf('Not applicable') === -1) devices[i].label = parts[1];\n          }\n          if ('PROTOCOL' === parts[0]) devices[i].protocol = parts[1];\n          if ('DISKSIZE' === parts[0]) devices[i].size = parseBytes(parts[1]);\n          if ('FILESYSTEMPERSONALITY' === parts[0]) devices[i].fstype = parts[1];\n          if ('MOUNTPOINT' === parts[0]) devices[i].mount = parts[1];\n          if ('VOLUMEUUID' === parts[0]) devices[i].uuid = parts[1];\n          if ('READ-ONLYMEDIA' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'CD/DVD';\n          if ('SOLIDSTATE' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'SSD';\n          if ('VIRTUAL' === parts[0]) devices[i].type = 'virtual';\n          if ('REMOVABLEMEDIA' === parts[0]) devices[i].removable = (parts[1] === 'Removable');\n          if ('PARTITIONTYPE' === parts[0]) devices[i].type = 'part';\n          if ('DEVICE/MEDIANAME' === parts[0]) devices[i].model = parts[1];\n        }\n      }\n    }\n  });\n  return devices;\n}\n\nfunction parseBlk(lines) {\n  let data = [];\n\n  lines.filter(line => line !== '').forEach((line) => {\n    try {\n      line = decodeURIComponent(line.replace(/\\\\x/g, '%'));\n      line = line.replace(/\\\\/g, '\\\\\\\\');\n      let disk = JSON.parse(line);\n      data.push({\n        'name': disk.name,\n        'type': disk.type,\n        'fstype': disk.fstype,\n        'mount': disk.mountpoint,\n        'size': parseInt(disk.size),\n        'physical': (disk.type === 'disk' ? (disk.rota === '0' ? 'SSD' : 'HDD') : (disk.type === 'rom' ? 'CD/DVD' : '')),\n        'uuid': disk.uuid,\n        'label': disk.label,\n        'model': disk.model,\n        'serial': disk.serial,\n        'removable': disk.rm === '1',\n        'protocol': disk.tran,\n        'group': disk.group,\n      });\n    } catch (e) {\n      util.noop();\n    }\n  });\n  data = util.unique(data);\n  data = util.sortByKey(data, ['type', 'name']);\n  return data;\n}\n\nfunction blkStdoutToObject(stdout) {\n  return stdout.toString()\n    .replace(/NAME=/g, '{\"name\":')\n    .replace(/FSTYPE=/g, ',\"fstype\":')\n    .replace(/TYPE=/g, ',\"type\":')\n    .replace(/SIZE=/g, ',\"size\":')\n    .replace(/MOUNTPOINT=/g, ',\"mountpoint\":')\n    .replace(/UUID=/g, ',\"uuid\":')\n    .replace(/ROTA=/g, ',\"rota\":')\n    .replace(/RO=/g, ',\"ro\":')\n    .replace(/RM=/g, ',\"rm\":')\n    .replace(/TRAN=/g, ',\"tran\":')\n    .replace(/SERIAL=/g, ',\"serial\":')\n    .replace(/LABEL=/g, ',\"label\":')\n    .replace(/MODEL=/g, ',\"model\":')\n    .replace(/OWNER=/g, ',\"owner\":')\n    .replace(/GROUP=/g, ',\"group\":')\n    .replace(/\\n/g, '}\\n');\n}\n\nfunction blockDevices(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux) {\n        // see https://wiki.ubuntuusers.de/lsblk/\n        // exec(\"lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME\", function (error, stdout) {\n        exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null', function (error, stdout) {\n          if (!error) {\n            let lines = blkStdoutToObject(stdout).split('\\n');\n            data = parseBlk(lines);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null', function (error, stdout) {\n              if (!error) {\n                let lines = blkStdoutToObject(stdout).split('\\n');\n                data = parseBlk(lines);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        exec('diskutil info -all', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            // parse lines into temp array of devices\n            data = parseDevices(lines);\n          }\n          if (callback) {\n            callback(data);\n          }\n          resolve(data);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        let drivetypes = ['Unknown', 'NoRoot', 'Removable', 'Local', 'Network', 'CD/DVD', 'RAM'];\n        try {\n          util.wmic('logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /value').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                let drivetype = util.getValue(lines, 'drivetype', '=');\n                if (drivetype) {\n                  data.push({\n                    name: util.getValue(lines, 'name', '='),\n                    identifier: util.getValue(lines, 'caption', '='),\n                    type: 'disk',\n                    fstype: util.getValue(lines, 'filesystem', '=').toLowerCase(),\n                    mount: util.getValue(lines, 'caption', '='),\n                    size: util.getValue(lines, 'size', '='),\n                    physical: (drivetype >= 0 && drivetype <= 6) ? drivetypes[drivetype] : drivetypes[0],\n                    uuid: util.getValue(lines, 'volumeserialnumber', '='),\n                    label: util.getValue(lines, 'volumename', '='),\n                    model: '',\n                    serial: util.getValue(lines, 'volumeserialnumber', '='),\n                    removable: drivetype === '2',\n                    protocol: ''\n                  });\n                }\n              });\n            }\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.blockDevices = blockDevices;\n\n// --------------------------\n// FS - speed\n\nfunction calcFsSpeed(rx, wx) {\n  let result = {\n    rx: 0,\n    wx: 0,\n    tx: 0,\n    rx_sec: -1,\n    wx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_fs_speed && _fs_speed.ms) {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    result.ms = Date.now() - _fs_speed.ms;\n    result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);\n    result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);\n    result.tx_sec = result.rx_sec + result.wx_sec;\n    _fs_speed.rx_sec = result.rx_sec;\n    _fs_speed.wx_sec = result.wx_sec;\n    _fs_speed.tx_sec = result.tx_sec;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    _fs_speed.rx_sec = -1;\n    _fs_speed.wx_sec = -1;\n    _fs_speed.tx_sec = -1;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = 0;\n  }\n  return result;\n}\n\nfunction fsStats(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n        reject(error);\n      }\n\n      let result = {\n        rx: 0,\n        wx: 0,\n        tx: 0,\n        rx_sec: -1,\n        wx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n\n      let rx = 0;\n      let wx = 0;\n      if ((_fs_speed && !_fs_speed.ms) || (_fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500)) {\n        if (_linux) {\n          // exec(\"df -k | grep /dev/\", function(error, stdout) {\n          exec('lsblk 2>/dev/null | grep /', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              let fs_filter = [];\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.replace(/[├─│└]+/g, '').trim().split(' ');\n                  if (fs_filter.indexOf(line[0]) === -1) fs_filter.push(line[0]);\n                }\n              });\n\n              let output = fs_filter.join('|');\n              exec('cat /proc/diskstats | egrep \"' + output + '\"', function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.forEach(function (line) {\n                    line = line.trim();\n                    if (line !== '') {\n                      line = line.replace(/ +/g, ' ').split(' ');\n\n                      rx += parseInt(line[5]) * 512;\n                      wx += parseInt(line[9]) * 512;\n                    }\n                  });\n                  result = calcFsSpeed(rx, wx);\n                }\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rx += parseInt(line[2]);\n                  wx += parseInt(line[9]);\n                }\n              });\n              result = calcFsSpeed(rx, wx);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.ms = _fs_speed.last_ms;\n        result.rx = _fs_speed.bytes_read;\n        result.wx = _fs_speed.bytes_write;\n        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;\n        result.rx_sec = _fs_speed.rx_sec;\n        result.wx_sec = _fs_speed.wx_sec;\n        result.tx_sec = _fs_speed.tx_sec;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsStats = fsStats;\n\nfunction calcDiskIO(rIO, wIO) {\n  let result = {\n    rIO: 0,\n    wIO: 0,\n    tIO: 0,\n    rIO_sec: -1,\n    wIO_sec: -1,\n    tIO_sec: -1,\n    ms: 0\n  };\n  if (_disk_io && _disk_io.ms) {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.ms = Date.now() - _disk_io.ms;\n    result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);\n    result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);\n    result.tIO_sec = result.rIO_sec + result.wIO_sec;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = result.rIO_sec;\n    _disk_io.wIO_sec = result.wIO_sec;\n    _disk_io.tIO_sec = result.tIO_sec;\n    _disk_io.last_ms = result.ms;\n    _disk_io.ms = Date.now();\n  } else {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = -1;\n    _disk_io.wIO_sec = -1;\n    _disk_io.tIO_sec = -1;\n    _disk_io.last_ms = 0;\n    _disk_io.ms = Date.now();\n  }\n  return result;\n}\n\nfunction disksIO(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n        reject(error);\n      }\n      if (_sunos) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) {\n          callback(NOT_SUPPORTED);\n        }\n        reject(error);\n      }\n\n      let result = {\n        rIO: 0,\n        wIO: 0,\n        tIO: 0,\n        rIO_sec: -1,\n        wIO_sec: -1,\n        tIO_sec: -1,\n        ms: 0\n      };\n      let rIO = 0;\n      let wIO = 0;\n\n      if ((_disk_io && !_disk_io.ms) || (_disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500)) {\n        if (_linux || _freebsd || _openbsd || _netbsd) {\n          // prints Block layer statistics for all mounted volumes\n          // var cmd = \"for mount in `lsblk | grep / | sed -r 's/│ └─//' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          // var cmd = \"for mount in `lsblk | grep / | sed 's/[│└─├]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          let cmd = 'for mount in `lsblk 2>/dev/null | grep \" disk \" | sed \"s/[│└─├]//g\" | awk \\'{$1=$1};1\\' | cut -d \" \" -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r \"s/ +/;/g\" | sed -r \"s/^;//\"; done';\n\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.split('\\n');\n              lines.forEach(function (line) {\n                // ignore empty lines\n                if (!line) return;\n\n                // sum r/wIO of all disks to compute all disks IO\n                let stats = line.split(';');\n                rIO += parseInt(stats[0]);\n                wIO += parseInt(stats[4]);\n              });\n              result = calcDiskIO(rIO, wIO);\n\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rIO += parseInt(line[10]);\n                  wIO += parseInt(line[0]);\n                }\n              });\n              result = calcDiskIO(rIO, wIO);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.rIO = _disk_io.rIO;\n        result.wIO = _disk_io.wIO;\n        result.tIO = _disk_io.rIO + _disk_io.wIO;\n        result.ms = _disk_io.last_ms;\n        result.rIO_sec = _disk_io.rIO_sec;\n        result.wIO_sec = _disk_io.wIO_sec;\n        result.tIO_sec = _disk_io.tIO_sec;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.disksIO = disksIO;\n\nfunction diskLayout(callback) {\n\n  function getVendorFromModel(model) {\n    const diskManufacturers = [\n      { pattern: '^WESTERN.+', manufacturer: 'Western Digital' },\n      { pattern: '^WDC.+', manufacturer: 'Western Digital' },\n      { pattern: 'WD.+', manufacturer: 'Western Digital' },\n      { pattern: '^TOSHIBA.+', manufacturer: 'Toshiba' },\n      { pattern: '^HITACHI.+', manufacturer: 'Hitachi' },\n      { pattern: '^IC.+', manufacturer: 'Hitachi' },\n      { pattern: '^HTS.+', manufacturer: 'Hitachi' },\n      { pattern: '^SANDISK.+', manufacturer: 'SanDisk' },\n      { pattern: '^KINGSTON.+', manufacturer: 'Kingston Technonogy' },\n      { pattern: '^SONY.+', manufacturer: 'Sony' },\n      { pattern: '^TRANSCEND.+', manufacturer: 'Transcend' },\n      { pattern: 'SAMSUNG.+', manufacturer: 'Samsung' },\n      { pattern: '^ST(?!I\\\\ ).+', manufacturer: 'Seagate' },\n      { pattern: '^STI\\\\ .+', manufacturer: 'SimpleTech' },\n      { pattern: '^D...-.+', manufacturer: 'IBM' },\n      { pattern: '^IBM.+', manufacturer: 'IBM' },\n      { pattern: '^FUJITSU.+', manufacturer: 'Fujitsu' },\n      { pattern: '^MP.+', manufacturer: 'Fujitsu' },\n      { pattern: '^MK.+', manufacturer: 'Toshiba' },\n      { pattern: '^MAXTOR.+', manufacturer: 'Maxtor' },\n      { pattern: '^Pioneer.+', manufacturer: 'Pioneer' },\n      { pattern: '^PHILIPS.+', manufacturer: 'Philips' },\n      { pattern: '^QUANTUM.+', manufacturer: 'Quantum Technology' },\n      { pattern: 'FIREBALL.+', manufacturer: 'Quantum Technology' },\n      { pattern: '^VBOX.+', manufacturer: 'VirtualBox' },\n      { pattern: 'CORSAIR.+', manufacturer: 'Corsair Components' },\n      { pattern: 'CRUCIAL.+', manufacturer: 'Crucial' },\n      { pattern: 'ECM.+', manufacturer: 'ECM' },\n      { pattern: 'INTEL.+', manufacturer: 'INTEL' },\n    ];\n\n    let result = '';\n    if (model) {\n      model = model.toUpperCase();\n      diskManufacturers.forEach((manufacturer) => {\n        const re = RegExp(manufacturer.pattern);\n        if (re.test(model)) { result = manufacturer.manufacturer; }\n      });\n    }\n    return result;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const commitResult = res => {\n        for (let i = 0; i < res.length; i++) {\n          delete res[i].BSDName;\n        }\n        if (callback) {\n          callback(res);\n        }\n        resolve(res);\n      };\n\n      let result = [];\n      let cmd = '';\n\n      if (_linux) {\n        let cmdFullSmart = '';\n\n        exec('export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            try {\n              const out = stdout.toString().trim();\n              let devices = [];\n              try {\n                const outJSON = JSON.parse(out);\n                if (outJSON && {}.hasOwnProperty.call(outJSON, 'blockdevices')) {\n                  devices = outJSON.blockdevices.filter(item => { return (item.group === 'disk' || item.type === 'disk') && item.size > 0 && (item.model !== null || (item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null)); });\n                }\n              } catch (e) {\n                // fallback to older version of lsblk\n                const out2 = execSync('export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL').toString();\n                let lines = blkStdoutToObject(out2).split('\\n');\n                const data = parseBlk(lines);\n                devices = data.filter(item => { return (item.group === 'disk' || item.type === 'disk') && item.size > 0 && ((item.model !== null && item.model !== '') || (item.mountpoint === '' && item.label === '' && item.fstype === '')); });\n              }\n              devices.forEach((device) => {\n                let mediumType = '';\n                const BSDName = '/dev/' + device.name;\n                const logical = device.name;\n                try {\n                  mediumType = execSync('cat /sys/block/' + logical + '/queue/rotational 2>/dev/null').toString().split('\\n')[0];\n                } catch (e) {\n                  util.noop();\n                }\n                let interfaceType = device.tran ? device.tran.toUpperCase().trim() : '';\n                if (interfaceType === 'NVME') {\n                  mediumType = '2';\n                  interfaceType = 'PCIe';\n                }\n                result.push({\n                  device: BSDName,\n                  type: (mediumType === '0' ? 'SSD' : (mediumType === '1' ? 'HD' : (mediumType === '2' ? 'NVMe' : (device.model && device.model.indexOf('SSD') > -1 ? 'SSD' : (device.model && device.model.indexOf('NVM') > -1 ? 'NVMe' : 'HD'))))),\n                  name: device.model || '',\n                  vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ''),\n                  size: device.size || 0,\n                  bytesPerSector: -1,\n                  totalCylinders: -1,\n                  totalHeads: -1,\n                  totalSectors: -1,\n                  totalTracks: -1,\n                  tracksPerCylinder: -1,\n                  sectorsPerTrack: -1,\n                  firmwareRevision: device.rev ? device.rev.trim() : '',\n                  serialNum: device.serial ? device.serial.trim() : '',\n                  interfaceType: interfaceType,\n                  smartStatus: 'unknown',\n                  BSDName: BSDName\n                });\n                cmd += `printf \"\\n${BSDName}|\"; smartctl -H ${BSDName} | grep overall;`;\n                cmdFullSmart += `${cmdFullSmart ? 'printf \",\";' : ''}smartctl -a -j ${BSDName};`;\n              });\n            } catch (e) {\n              util.noop();\n            }\n          }\n          // check S.M.A.R.T. status\n          if (cmdFullSmart) {\n            exec(cmdFullSmart, function (error, stdout) {\n              try {\n                const data = JSON.parse(`[${stdout}]`);\n                data.forEach(disk => {\n                  const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];\n\n                  for (let i = 0; i < result.length; i++) {\n                    if (result[i].BSDName === diskBSDName) {\n                      result[i].smartStatus = (disk.smart_status.passed ? 'Ok' : (disk.smart_status.passed === false ? 'Predicted Failure' : 'unknown'));\n                      result[i].smartData = disk;\n                    }\n                  }\n                });\n                commitResult(result);\n              } catch (e) {\n                if (cmd) {\n                  cmd = cmd + 'printf \"\\n\"';\n                  exec(cmd, function (error, stdout) {\n                    let lines = stdout.toString().split('\\n');\n                    lines.forEach(line => {\n                      if (line) {\n                        let parts = line.split('|');\n                        if (parts.length === 2) {\n                          let BSDName = parts[0];\n                          parts[1] = parts[1].trim();\n                          let parts2 = parts[1].split(':');\n                          if (parts2.length === 2) {\n                            parts2[1] = parts2[1].trim();\n                            let status = parts2[1].toLowerCase();\n                            for (let i = 0; i < result.length; i++) {\n                              if (result[i].BSDName === BSDName) {\n                                result[i].smartStatus = (status === 'passed' ? 'Ok' : (status === 'failed!' ? 'Predicted Failure' : 'unknown'));\n                              }\n                            }\n                          }\n                        }\n                      }\n                    });\n                    commitResult(result);\n                  });\n                } else {\n                  commitResult(result);\n                }\n              }\n            });\n          } else {\n            commitResult(result);\n          }\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_darwin) {\n        exec('system_profiler SPSerialATADataType SPNVMeDataType', function (error, stdout) {\n          if (!error) {\n            let parts = stdout.toString().split('NVMExpress:');\n\n            let devices = parts[0].split(' Physical Interconnect: ');\n            devices.shift();\n            devices.forEach(function (device) {\n              device = 'InterfaceType: ' + device;\n              let lines = device.split('\\n');\n              const mediumType = util.getValue(lines, 'Medium Type', ':', true).trim();\n              const sizeStr = util.getValue(lines, 'capacity', ':', true).trim();\n              const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n              if (sizeStr) {\n                let sizeValue = 0;\n                if (sizeStr.indexOf('(') >= 0) {\n                  sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, ''));\n                }\n                if (!sizeValue) {\n                  sizeValue = parseInt(sizeStr);\n                }\n                if (sizeValue) {\n                  result.push({\n                    device: BSDName,\n                    type: mediumType.startsWith('Solid') ? 'SSD' : 'HD',\n                    name: util.getValue(lines, 'Model', ':', true).trim(),\n                    vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                    size: sizeValue,\n                    bytesPerSector: -1,\n                    totalCylinders: -1,\n                    totalHeads: -1,\n                    totalSectors: -1,\n                    totalTracks: -1,\n                    tracksPerCylinder: -1,\n                    sectorsPerTrack: -1,\n                    firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                    serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                    interfaceType: util.getValue(lines, 'InterfaceType', ':', true).trim(),\n                    smartStatus: 'unknown',\n                    BSDName: BSDName\n                  });\n                  cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                }\n              }\n            });\n            if (parts.length > 1) {\n              let devices = parts[1].split('\\n\\n          Capacity:');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = '!Capacity: ' + device;\n                let lines = device.split('\\n');\n                const linkWidth = util.getValue(lines, 'link width', ':', true).trim();\n                const sizeStr = util.getValue(lines, '!capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    result.push({\n                      device: BSDName,\n                      type: 'NVMe',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: -1,\n                      totalCylinders: -1,\n                      totalHeads: -1,\n                      totalSectors: -1,\n                      totalTracks: -1,\n                      tracksPerCylinder: -1,\n                      sectorsPerTrack: -1,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: ('PCIe ' + linkWidth).trim(),\n                      smartStatus: 'unknown',\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            }\n          }\n          if (cmd) {\n            cmd = cmd + 'printf \"\\n\"';\n            exec(cmd, function (error, stdout) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(line => {\n                if (line) {\n                  let parts = line.split('|');\n                  if (parts.length === 2) {\n                    let BSDName = parts[0];\n                    parts[1] = parts[1].trim();\n                    let parts2 = parts[1].split(':');\n                    if (parts2.length === 2) {\n                      parts2[1] = parts2[1].trim();\n                      let status = parts2[1].toLowerCase();\n                      for (let i = 0; i < result.length; i++) {\n                        if (result[i].BSDName === BSDName) {\n                          result[i].smartStatus = (status === 'not supported' ? 'not supported' : (status === 'verified' ? 'Ok' : (status === 'failing' ? 'Predicted Failure' : 'unknown')));\n                        }\n                      }\n                    }\n                  }\n                }\n              });\n              for (let i = 0; i < result.length; i++) {\n                delete result[i].BSDName;\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          } else {\n            for (let i = 0; i < result.length; i++) {\n              delete result[i].BSDName;\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        });\n      }\n      if (_windows) {\n        try {\n          util.wmic('diskdrive get /value').then((stdout, error) => {\n            let devices = stdout.toString().split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const size = util.getValue(lines, 'Size', '=').trim();\n              const status = util.getValue(lines, 'Status', '=').trim().toLowerCase();\n              if (size) {\n                result.push({\n                  device: '',\n                  type: device.indexOf('SSD') > -1 ? 'SSD' : 'HD',  // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below\n                  name: util.getValue(lines, 'Caption', '='),\n                  vendor: util.getValue(lines, 'Manufacturer', '='),\n                  size: parseInt(size),\n                  bytesPerSector: parseInt(util.getValue(lines, 'BytesPerSector', '=')),\n                  totalCylinders: parseInt(util.getValue(lines, 'TotalCylinders', '=')),\n                  totalHeads: parseInt(util.getValue(lines, 'TotalHeads', '=')),\n                  totalSectors: parseInt(util.getValue(lines, 'TotalSectors', '=')),\n                  totalTracks: parseInt(util.getValue(lines, 'TotalTracks', '=')),\n                  tracksPerCylinder: parseInt(util.getValue(lines, 'TracksPerCylinder', '=')),\n                  sectorsPerTrack: parseInt(util.getValue(lines, 'SectorsPerTrack', '=')),\n                  firmwareRevision: util.getValue(lines, 'FirmwareRevision', '=').trim(),\n                  serialNum: util.getValue(lines, 'SerialNumber', '=').trim(),\n                  interfaceType: util.getValue(lines, 'InterfaceType', '=').trim(),\n                  smartStatus: (status === 'ok' ? 'Ok' : (status === 'degraded' ? 'Degraded' : (status === 'pred fail' ? 'Predicted Failure' : 'Unknown')))\n                });\n              }\n            });\n            util.powerShell('Get-PhysicalDisk | Format-List')\n              .then(data => {\n                let devices = data.split(/\\n\\s*\\n/);\n                devices.forEach(function (device) {\n                  let lines = device.split('\\r\\n');\n                  const serialNum = util.getValue(lines, 'SerialNumber', ':').trim();\n                  const name = util.getValue(lines, 'FriendlyName', ':').trim().replace('Msft ', 'Microsoft');\n                  const size = util.getValue(lines, 'Size', ':').trim();\n                  const model = util.getValue(lines, 'Model', ':').trim();\n                  const interfaceType = util.getValue(lines, 'BusType', ':').trim();\n                  let mediaType = util.getValue(lines, 'MediaType', ':').trim();\n                  if (mediaType === '3' || mediaType === 'HDD') { mediaType = 'HD'; }\n                  if (mediaType === '4') { mediaType = 'SSD'; }\n                  if (mediaType === '5') { mediaType = 'SCM'; }\n                  if (mediaType === 'Unspecified' && (model.toLowerCase().indexOf('virtual') > -1 || model.toLowerCase().indexOf('vbox') > -1)) { mediaType = 'Virtual'; }\n                  if (size) {\n                    let i = util.findObjectByKey(result, 'serialNum', serialNum);\n                    if (i === -1 || serialNum === '') {\n                      i = util.findObjectByKey(result, 'name', name);\n                    }\n                    if (i != -1) {\n                      result[i].type = mediaType;\n                      result[i].interfaceType = interfaceType;\n                    }\n                  }\n                });\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              })\n              .catch(() => {\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.diskLayout = diskLayout;\n"]},"metadata":{},"sourceType":"script"}