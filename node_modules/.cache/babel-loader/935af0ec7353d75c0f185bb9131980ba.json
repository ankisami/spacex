{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar Stream = require('stream').Writable;\n\nvar encode = require('./encode');\n/**\n * Expose parser.\n */\n\n\nmodule.exports = Parser;\n/**\n * Initialize parser.\n *\n * @param {Options} [opts]\n * @api public\n */\n\nfunction Parser(opts) {\n  Stream.call(this, opts);\n  this.state = 'message';\n  this._lenbuf = new Buffer(4);\n}\n/**\n * Inherit from `Stream.prototype`.\n */\n\n\nParser.prototype.__proto__ = Stream.prototype;\n/**\n * Write implementation.\n */\n\nParser.prototype._write = function (chunk, encoding, fn) {\n  for (var i = 0; i < chunk.length; i++) {\n    switch (this.state) {\n      case 'message':\n        var meta = chunk[i];\n        this.version = meta >> 4;\n        this.argv = meta & 0xf;\n        this.state = 'arglen';\n        this._bufs = [new Buffer([meta])];\n        this._nargs = 0;\n        this._leni = 0;\n        break;\n\n      case 'arglen':\n        this._lenbuf[this._leni++] = chunk[i]; // done\n\n        if (4 == this._leni) {\n          this._arglen = this._lenbuf.readUInt32BE(0);\n          var buf = new Buffer(4);\n          buf[0] = this._lenbuf[0];\n          buf[1] = this._lenbuf[1];\n          buf[2] = this._lenbuf[2];\n          buf[3] = this._lenbuf[3];\n\n          this._bufs.push(buf);\n\n          this._argcur = 0;\n          this.state = 'arg';\n        }\n\n        break;\n\n      case 'arg':\n        // bytes remaining in the argument\n        var rem = this._arglen - this._argcur; // consume the chunk we need to complete\n        // the argument, or the remainder of the\n        // chunk if it's not mixed-boundary\n\n        var pos = Math.min(rem + i, chunk.length); // slice arg chunk\n\n        var part = chunk.slice(i, pos);\n\n        this._bufs.push(part); // check if we have the complete arg\n\n\n        this._argcur += pos - i;\n        var done = this._argcur == this._arglen;\n        i = pos - 1;\n        if (done) this._nargs++; // no more args\n\n        if (this._nargs == this.argv) {\n          this.state = 'message';\n          this.emit('data', Buffer.concat(this._bufs));\n          break;\n        }\n\n        if (done) {\n          this.state = 'arglen';\n          this._leni = 0;\n        }\n\n        break;\n    }\n  }\n\n  fn();\n};","map":{"version":3,"sources":["/Users/samianki/node_modules/amp/lib/stream.js"],"names":["Stream","require","Writable","encode","module","exports","Parser","opts","call","state","_lenbuf","Buffer","prototype","__proto__","_write","chunk","encoding","fn","i","length","meta","version","argv","_bufs","_nargs","_leni","_arglen","readUInt32BE","buf","push","_argcur","rem","pos","Math","min","part","slice","done","emit","concat"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar Stream = require('stream').Writable;\nvar encode = require('./encode');\n\n/**\n * Expose parser.\n */\n\nmodule.exports = Parser;\n\n/**\n * Initialize parser.\n *\n * @param {Options} [opts]\n * @api public\n */\n\nfunction Parser(opts) {\n  Stream.call(this, opts);\n  this.state = 'message';\n  this._lenbuf = new Buffer(4);\n}\n\n/**\n * Inherit from `Stream.prototype`.\n */\n\nParser.prototype.__proto__ = Stream.prototype;\n\n/**\n * Write implementation.\n */\n\nParser.prototype._write = function(chunk, encoding, fn){\n  for (var i = 0; i < chunk.length; i++) {\n    switch (this.state) {\n      case 'message':\n        var meta = chunk[i];\n        this.version = meta >> 4;\n        this.argv = meta & 0xf;\n        this.state = 'arglen';\n        this._bufs = [new Buffer([meta])];\n        this._nargs = 0;\n        this._leni = 0;\n        break;\n\n      case 'arglen':\n        this._lenbuf[this._leni++] = chunk[i];\n\n        // done\n        if (4 == this._leni) {\n          this._arglen = this._lenbuf.readUInt32BE(0);\n          var buf = new Buffer(4);\n          buf[0] = this._lenbuf[0];\n          buf[1] = this._lenbuf[1];\n          buf[2] = this._lenbuf[2];\n          buf[3] = this._lenbuf[3];\n          this._bufs.push(buf);\n          this._argcur = 0;\n          this.state = 'arg';\n        }\n        break;\n\n      case 'arg':\n        // bytes remaining in the argument\n        var rem = this._arglen - this._argcur;\n\n        // consume the chunk we need to complete\n        // the argument, or the remainder of the\n        // chunk if it's not mixed-boundary\n        var pos = Math.min(rem + i, chunk.length);\n\n        // slice arg chunk\n        var part = chunk.slice(i, pos);\n        this._bufs.push(part);\n\n        // check if we have the complete arg\n        this._argcur += pos - i;\n        var done = this._argcur == this._arglen;\n        i = pos - 1;\n\n        if (done) this._nargs++;\n\n        // no more args\n        if (this._nargs == this.argv) {\n          this.state = 'message';\n          this.emit('data', Buffer.concat(this._bufs));\n          break;\n        }\n\n        if (done) {\n          this.state = 'arglen';\n          this._leni = 0;\n        }\n        break;\n    }\n  }\n\n\n  fn();\n};"]},"metadata":{},"sourceType":"script"}