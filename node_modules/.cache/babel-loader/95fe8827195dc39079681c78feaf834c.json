{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar updateCpu = require('./helpers/cpu');\n\nvar parallel = require('./helpers/parallel');\n\nvar history = require('./history');\n\nvar cpuInfo = null;\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar SIZE = 1024; // if the stat file is bigger then this I'll buy you a drink\n\nfunction noop() {}\n\nfunction open(path, history, cb) {\n  if (history.fd) {\n    return cb(null, history.fd);\n  }\n\n  fs.open(path, 'r', cb);\n}\n\nfunction close(history) {\n  if (history.fd) {\n    fs.close(history.fd, noop);\n  }\n}\n\nfunction readUntilEnd(fd, buf, cb) {\n  var firstRead = false;\n\n  if (typeof buf === 'function') {\n    cb = buf;\n    buf = Buffer.alloc(SIZE);\n    firstRead = true;\n  }\n\n  fs.read(fd, buf, 0, SIZE, 0, function (err, bytesRead, buffer) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    var data = Buffer.concat([buf, buffer], firstRead ? bytesRead : buf.length + bytesRead);\n\n    if (bytesRead === SIZE) {\n      readUntilEnd(fd, data, cb);\n      return;\n    }\n\n    cb(null, buf);\n  });\n}\n\nfunction readProcFile(pid, options, done) {\n  var hst = history.get(pid, options.maxage);\n  var again = false;\n\n  if (hst === undefined) {\n    again = true;\n    hst = {};\n  } // Arguments to path.join must be strings\n\n\n  open(path.join('/proc', '' + pid, 'stat'), hst, function (err, fd) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        err.message = 'No matching pid found';\n      }\n\n      return done(err, null);\n    }\n\n    if (err) {\n      return done(err);\n    }\n\n    readUntilEnd(fd, function (err, buffer) {\n      if (err) {\n        return done(err);\n      }\n\n      var infos = buffer.toString('utf8');\n      var date = Date.now(); // https://github.com/arunoda/node-usage/commit/a6ca74ecb8dd452c3c00ed2bde93294d7bb75aa8\n      // preventing process space in name by removing values before last ) (pid (name) ...)\n\n      var index = infos.lastIndexOf(')');\n      infos = infos.substr(index + 2).split(' '); // according to http://man7.org/linux/man-pages/man5/proc.5.html (index 0 based - 2)\n      // In kernels before Linux 2.6, start was expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks\n\n      var stat = {\n        ppid: parseInt(infos[1]),\n        utime: parseFloat(infos[11]) * 1000 / cpuInfo.clockTick,\n        stime: parseFloat(infos[12]) * 1000 / cpuInfo.clockTick,\n        cutime: parseFloat(infos[13]) * 1000 / cpuInfo.clockTick,\n        cstime: parseFloat(infos[14]) * 1000 / cpuInfo.clockTick,\n        start: parseFloat(infos[19]) * 1000 / cpuInfo.clockTick,\n        rss: parseFloat(infos[21]),\n        uptime: cpuInfo.uptime * 1000,\n        fd: fd\n      };\n      var memory = stat.rss * cpuInfo.pageSize; // https://stackoverflow.com/a/16736599/3921589\n\n      var childrens = options.childrens ? stat.cutime + stat.cstime : 0; // process usage since last call in seconds\n\n      var total = stat.stime - (hst.stime || 0) + stat.utime - (hst.utime || 0) + childrens; // time elapsed between calls in seconds\n\n      var seconds = Math.abs(hst.uptime !== undefined ? stat.uptime - hst.uptime : stat.start - stat.uptime);\n      var cpu = seconds > 0 ? total / seconds * 100 : 0;\n      history.set(pid, stat, options.maxage, close);\n\n      if (again) {\n        return readProcFile(pid, options, done);\n      }\n\n      return done(null, {\n        cpu: cpu,\n        memory: memory,\n        ctime: stat.utime + stat.stime,\n        elapsed: stat.uptime - stat.start,\n        timestamp: date,\n        pid: pid,\n        ppid: stat.ppid\n      });\n    });\n  });\n}\n\nfunction procfile(pids, options, done) {\n  updateCpu(cpuInfo, function (err, result) {\n    if (err) return done(err);\n    cpuInfo = result;\n    var fns = {};\n    pids.forEach(function (pid, i) {\n      fns[pid] = function (cb) {\n        readProcFile(pid, options, cb);\n      };\n    });\n    parallel(fns, {\n      graceful: true\n    }, done);\n  });\n}\n\nmodule.exports = procfile;","map":{"version":3,"sources":["/Users/samianki/node_modules/pidusage/lib/procfile.js"],"names":["fs","require","path","updateCpu","parallel","history","cpuInfo","Buffer","SIZE","noop","open","cb","fd","close","readUntilEnd","buf","firstRead","alloc","read","err","bytesRead","buffer","data","concat","length","readProcFile","pid","options","done","hst","get","maxage","again","undefined","join","code","message","infos","toString","date","Date","now","index","lastIndexOf","substr","split","stat","ppid","parseInt","utime","parseFloat","clockTick","stime","cutime","cstime","start","rss","uptime","memory","pageSize","childrens","total","seconds","Math","abs","cpu","set","ctime","elapsed","timestamp","procfile","pids","result","fns","forEach","i","graceful","module","exports"],"mappings":"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","sourcesContent":["var fs = require('fs')\nvar path = require('path')\nvar updateCpu = require('./helpers/cpu')\nvar parallel = require('./helpers/parallel')\nvar history = require('./history')\nvar cpuInfo = null\nvar Buffer = require('safe-buffer').Buffer\nvar SIZE = 1024 // if the stat file is bigger then this I'll buy you a drink\n\nfunction noop () {}\n\nfunction open (path, history, cb) {\n  if (history.fd) { return cb(null, history.fd) }\n  fs.open(path, 'r', cb)\n}\n\nfunction close (history) {\n  if (history.fd) {\n    fs.close(history.fd, noop)\n  }\n}\n\nfunction readUntilEnd (fd, buf, cb) {\n  var firstRead = false\n  if (typeof buf === 'function') {\n    cb = buf\n    buf = Buffer.alloc(SIZE)\n    firstRead = true\n  }\n\n  fs.read(fd, buf, 0, SIZE, 0, function (err, bytesRead, buffer) {\n    if (err) {\n      cb(err)\n      return\n    }\n\n    var data = Buffer.concat([buf, buffer], firstRead ? bytesRead : buf.length + bytesRead)\n    if (bytesRead === SIZE) {\n      readUntilEnd(fd, data, cb)\n      return\n    }\n\n    cb(null, buf)\n  })\n}\n\nfunction readProcFile (pid, options, done) {\n  var hst = history.get(pid, options.maxage)\n  var again = false\n  if (hst === undefined) {\n    again = true\n    hst = {}\n  }\n\n  // Arguments to path.join must be strings\n  open(path.join('/proc', '' + pid, 'stat'), hst, function (err, fd) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        err.message = 'No matching pid found'\n      }\n      return done(err, null)\n    }\n\n    if (err) {\n      return done(err)\n    }\n\n    readUntilEnd(fd, function (err, buffer) {\n      if (err) {\n        return done(err)\n      }\n\n      var infos = buffer.toString('utf8')\n      var date = Date.now()\n\n      // https://github.com/arunoda/node-usage/commit/a6ca74ecb8dd452c3c00ed2bde93294d7bb75aa8\n      // preventing process space in name by removing values before last ) (pid (name) ...)\n      var index = infos.lastIndexOf(')')\n      infos = infos.substr(index + 2).split(' ')\n\n      // according to http://man7.org/linux/man-pages/man5/proc.5.html (index 0 based - 2)\n      // In kernels before Linux 2.6, start was expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks\n      var stat = {\n        ppid: parseInt(infos[1]),\n        utime: parseFloat(infos[11]) * 1000 / cpuInfo.clockTick,\n        stime: parseFloat(infos[12]) * 1000 / cpuInfo.clockTick,\n        cutime: parseFloat(infos[13]) * 1000 / cpuInfo.clockTick,\n        cstime: parseFloat(infos[14]) * 1000 / cpuInfo.clockTick,\n        start: parseFloat(infos[19]) * 1000 / cpuInfo.clockTick,\n        rss: parseFloat(infos[21]),\n        uptime: cpuInfo.uptime * 1000,\n        fd: fd\n      }\n\n      var memory = stat.rss * cpuInfo.pageSize\n\n      // https://stackoverflow.com/a/16736599/3921589\n      var childrens = options.childrens ? stat.cutime + stat.cstime : 0\n      // process usage since last call in seconds\n      var total = (stat.stime - (hst.stime || 0) + stat.utime - (hst.utime || 0) + childrens)\n      // time elapsed between calls in seconds\n      var seconds = Math.abs(hst.uptime !== undefined ? stat.uptime - hst.uptime : stat.start - stat.uptime)\n      var cpu = seconds > 0 ? (total / seconds) * 100 : 0\n\n      history.set(pid, stat, options.maxage, close)\n\n      if (again) {\n        return readProcFile(pid, options, done)\n      }\n\n      return done(null, {\n        cpu: cpu,\n        memory: memory,\n        ctime: stat.utime + stat.stime,\n        elapsed: stat.uptime - stat.start,\n        timestamp: date,\n        pid: pid,\n        ppid: stat.ppid\n      })\n    })\n  })\n}\n\nfunction procfile (pids, options, done) {\n  updateCpu(cpuInfo, function (err, result) {\n    if (err) return done(err)\n\n    cpuInfo = result\n    var fns = {}\n\n    pids.forEach(function (pid, i) {\n      fns[pid] = function (cb) {\n        readProcFile(pid, options, cb)\n      }\n    })\n\n    parallel(fns, { graceful: true }, done)\n  })\n}\n\nmodule.exports = procfile\n"]},"metadata":{},"sourceType":"script"}