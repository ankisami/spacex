{"ast":null,"code":"// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\nvar JSON5 = typeof exports === 'object' ? exports : {};\n\nJSON5.parse = function () {\n  \"use strict\"; // This is a function that can parse a JSON5 text, producing a JavaScript\n  // data structure. It is a simple, recursive descent parser. It does not use\n  // eval or regular expressions, so it can be used as a model for implementing\n  // a JSON5 parser in other languages.\n  // We are defining the function inside of another function to avoid creating\n  // global variables.\n\n  var at,\n      // The index of the current character\n  ch,\n      // The current character\n  escapee = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '\\\\': '\\\\',\n    '/': '/',\n    '\\n': '',\n    // Replace escaped newlines in strings w/ empty string\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n  },\n      ws = [' ', '\\t', '\\r', '\\n', '\\v', '\\f', '\\xA0', '\\uFEFF'],\n      text,\n      error = function (m) {\n    // Call error when something is wrong.\n    var error = new SyntaxError();\n    error.message = m;\n    error.at = at;\n    error.text = text;\n    throw error;\n  },\n      next = function (c) {\n    // If a c parameter is provided, verify that it matches the current character.\n    if (c && c !== ch) {\n      error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n    } // Get the next character. When there are no more characters,\n    // return the empty string.\n\n\n    ch = text.charAt(at);\n    at += 1;\n    return ch;\n  },\n      peek = function () {\n    // Get the next character without consuming it or\n    // assigning it to the ch varaible.\n    return text.charAt(at);\n  },\n      identifier = function () {\n    // Parse an identifier. Normally, reserved words are disallowed here, but we\n    // only use this for unquoted object keys, where reserved words are allowed,\n    // so we don't check for those here. References:\n    // - http://es5.github.com/#x7.6\n    // - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n    // - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n    var key = ch; // Identifiers must start with a letter, _ or $.\n\n    if (ch !== '_' && ch !== '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {\n      error(\"Bad identifier\");\n    } // Subsequent characters can contain digits.\n\n\n    while (next() && (ch === '_' || ch === '$' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')) {\n      key += ch;\n    }\n\n    return key;\n  },\n      number = function () {\n    // Parse a number value.\n    var number,\n        sign = '',\n        string = '',\n        base = 10;\n\n    if (ch === '-' || ch === '+') {\n      sign = ch;\n      next(ch);\n    } // support for Infinity (could tweak to allow other words):\n\n\n    if (ch === 'I') {\n      number = word();\n\n      if (typeof number !== 'number' || isNaN(number)) {\n        error('Unexpected word for number');\n      }\n\n      return sign === '-' ? -number : number;\n    } // support for NaN\n\n\n    if (ch === 'N') {\n      number = word();\n\n      if (!isNaN(number)) {\n        error('expected word to be NaN');\n      } // ignore sign as -NaN also is NaN\n\n\n      return number;\n    }\n\n    if (ch === '0') {\n      string += ch;\n      next();\n\n      if (ch === 'x' || ch === 'X') {\n        string += ch;\n        next();\n        base = 16;\n      } else if (ch >= '0' && ch <= '9') {\n        error('Octal literal');\n      }\n    }\n\n    switch (base) {\n      case 10:\n        while (ch >= '0' && ch <= '9') {\n          string += ch;\n          next();\n        }\n\n        if (ch === '.') {\n          string += '.';\n\n          while (next() && ch >= '0' && ch <= '9') {\n            string += ch;\n          }\n        }\n\n        if (ch === 'e' || ch === 'E') {\n          string += ch;\n          next();\n\n          if (ch === '-' || ch === '+') {\n            string += ch;\n            next();\n          }\n\n          while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n          }\n        }\n\n        break;\n\n      case 16:\n        while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n          string += ch;\n          next();\n        }\n\n        break;\n    }\n\n    if (sign === '-') {\n      number = -string;\n    } else {\n      number = +string;\n    }\n\n    if (!isFinite(number)) {\n      error(\"Bad number\");\n    } else {\n      return number;\n    }\n  },\n      string = function () {\n    // Parse a string value.\n    var hex,\n        i,\n        string = '',\n        delim,\n        // double quote or single quote\n    uffff; // When parsing for string values, we must look for ' or \" and \\ characters.\n\n    if (ch === '\"' || ch === \"'\") {\n      delim = ch;\n\n      while (next()) {\n        if (ch === delim) {\n          next();\n          return string;\n        } else if (ch === '\\\\') {\n          next();\n\n          if (ch === 'u') {\n            uffff = 0;\n\n            for (i = 0; i < 4; i += 1) {\n              hex = parseInt(next(), 16);\n\n              if (!isFinite(hex)) {\n                break;\n              }\n\n              uffff = uffff * 16 + hex;\n            }\n\n            string += String.fromCharCode(uffff);\n          } else if (ch === '\\r') {\n            if (peek() === '\\n') {\n              next();\n            }\n          } else if (typeof escapee[ch] === 'string') {\n            string += escapee[ch];\n          } else {\n            break;\n          }\n        } else if (ch === '\\n') {\n          // unescaped newlines are invalid; see:\n          // https://github.com/aseemk/json5/issues/24\n          // invalid unescaped chars?\n          break;\n        } else {\n          string += ch;\n        }\n      }\n    }\n\n    error(\"Bad string\");\n  },\n      inlineComment = function () {\n    // Skip an inline comment, assuming this is one. The current character should\n    // be the second / character in the // pair that begins this inline comment.\n    // To finish the inline comment, we look for a newline or the end of the text.\n    if (ch !== '/') {\n      error(\"Not an inline comment\");\n    }\n\n    do {\n      next();\n\n      if (ch === '\\n' || ch === '\\r') {\n        next();\n        return;\n      }\n    } while (ch);\n  },\n      blockComment = function () {\n    // Skip a block comment, assuming this is one. The current character should be\n    // the * character in the /* pair that begins this block comment.\n    // To finish the block comment, we look for an ending */ pair of characters,\n    // but we also watch for the end of text before the comment is terminated.\n    if (ch !== '*') {\n      error(\"Not a block comment\");\n    }\n\n    do {\n      next();\n\n      while (ch === '*') {\n        next('*');\n\n        if (ch === '/') {\n          next('/');\n          return;\n        }\n      }\n    } while (ch);\n\n    error(\"Unterminated block comment\");\n  },\n      comment = function () {\n    // Skip a comment, whether inline or block-level, assuming this is one.\n    // Comments always begin with a / character.\n    if (ch !== '/') {\n      error(\"Not a comment\");\n    }\n\n    next('/');\n\n    if (ch === '/') {\n      inlineComment();\n    } else if (ch === '*') {\n      blockComment();\n    } else {\n      error(\"Unrecognized comment\");\n    }\n  },\n      white = function () {\n    // Skip whitespace and comments.\n    // Note that we're detecting comments by only a single / character.\n    // This works since regular expressions are not valid JSON(5), but this will\n    // break if there are other valid values that begin with a / character!\n    while (ch) {\n      if (ch === '/') {\n        comment();\n      } else if (ws.indexOf(ch) >= 0) {\n        next();\n      } else {\n        return;\n      }\n    }\n  },\n      word = function () {\n    // true, false, or null.\n    switch (ch) {\n      case 't':\n        next('t');\n        next('r');\n        next('u');\n        next('e');\n        return true;\n\n      case 'f':\n        next('f');\n        next('a');\n        next('l');\n        next('s');\n        next('e');\n        return false;\n\n      case 'n':\n        next('n');\n        next('u');\n        next('l');\n        next('l');\n        return null;\n\n      case 'I':\n        next('I');\n        next('n');\n        next('f');\n        next('i');\n        next('n');\n        next('i');\n        next('t');\n        next('y');\n        return Infinity;\n\n      case 'N':\n        next('N');\n        next('a');\n        next('N');\n        return NaN;\n    }\n\n    error(\"Unexpected '\" + ch + \"'\");\n  },\n      value,\n      // Place holder for the value function.\n  array = function () {\n    // Parse an array value.\n    var array = [];\n\n    if (ch === '[') {\n      next('[');\n      white();\n\n      while (ch) {\n        if (ch === ']') {\n          next(']');\n          return array; // Potentially empty array\n        } // ES5 allows omitting elements in arrays, e.g. [,] and\n        // [,null]. We don't allow this in JSON5.\n\n\n        if (ch === ',') {\n          error(\"Missing array element\");\n        } else {\n          array.push(value());\n        }\n\n        white(); // If there's no comma after this value, this needs to\n        // be the end of the array.\n\n        if (ch !== ',') {\n          next(']');\n          return array;\n        }\n\n        next(',');\n        white();\n      }\n    }\n\n    error(\"Bad array\");\n  },\n      object = function () {\n    // Parse an object value.\n    var key,\n        object = {};\n\n    if (ch === '{') {\n      next('{');\n      white();\n\n      while (ch) {\n        if (ch === '}') {\n          next('}');\n          return object; // Potentially empty object\n        } // Keys can be unquoted. If they are, they need to be\n        // valid JS identifiers.\n\n\n        if (ch === '\"' || ch === \"'\") {\n          key = string();\n        } else {\n          key = identifier();\n        }\n\n        white();\n        next(':');\n        object[key] = value();\n        white(); // If there's no comma after this pair, this needs to be\n        // the end of the object.\n\n        if (ch !== ',') {\n          next('}');\n          return object;\n        }\n\n        next(',');\n        white();\n      }\n    }\n\n    error(\"Bad object\");\n  };\n\n  value = function () {\n    // Parse a JSON value. It could be an object, an array, a string, a number,\n    // or a word.\n    white();\n\n    switch (ch) {\n      case '{':\n        return object();\n\n      case '[':\n        return array();\n\n      case '\"':\n      case \"'\":\n        return string();\n\n      case '-':\n      case '+':\n      case '.':\n        return number();\n\n      default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n  }; // Return the json_parse function. It will have access to all of the above\n  // functions and variables.\n\n\n  return function (source, reviver) {\n    var result;\n    text = String(source);\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n\n    if (ch) {\n      error(\"Syntax error\");\n    } // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n\n    return typeof reviver === 'function' ? function walk(holder, key) {\n      var k,\n          v,\n          value = holder[key];\n\n      if (value && typeof value === 'object') {\n        for (k in value) {\n          if (Object.prototype.hasOwnProperty.call(value, k)) {\n            v = walk(value, k);\n\n            if (v !== undefined) {\n              value[k] = v;\n            } else {\n              delete value[k];\n            }\n          }\n        }\n      }\n\n      return reviver.call(holder, key, value);\n    }({\n      '': result\n    }, '') : result;\n  };\n}(); // JSON5 stringify will not quote keys where appropriate\n\n\nJSON5.stringify = function (obj, replacer, space) {\n  if (replacer && typeof replacer !== \"function\" && !isArray(replacer)) {\n    throw new Error('Replacer must be a function or an array');\n  }\n\n  var getReplacedValueOrUndefined = function (holder, key, isTopLevel) {\n    var value = holder[key]; // Replace the value with its toJSON value first, if possible\n\n    if (value && value.toJSON && typeof value.toJSON === \"function\") {\n      value = value.toJSON();\n    } // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n    // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n\n\n    if (typeof replacer === \"function\") {\n      return replacer.call(holder, key, value);\n    } else if (replacer) {\n      if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n        return value;\n      } else {\n        return undefined;\n      }\n    } else {\n      return value;\n    }\n  };\n\n  function isWordChar(char) {\n    return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char >= '0' && char <= '9' || char === '_' || char === '$';\n  }\n\n  function isWordStart(char) {\n    return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char === '_' || char === '$';\n  }\n\n  function isWord(key) {\n    if (typeof key !== 'string') {\n      return false;\n    }\n\n    if (!isWordStart(key[0])) {\n      return false;\n    }\n\n    var i = 1,\n        length = key.length;\n\n    while (i < length) {\n      if (!isWordChar(key[i])) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  } // export for use in tests\n\n\n  JSON5.isWord = isWord; // polyfills\n\n  function isArray(obj) {\n    if (Array.isArray) {\n      return Array.isArray(obj);\n    } else {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n  }\n\n  function isDate(obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]';\n  }\n\n  isNaN = isNaN || function (val) {\n    return typeof val === 'number' && val !== val;\n  };\n\n  var objStack = [];\n\n  function checkForCircular(obj) {\n    for (var i = 0; i < objStack.length; i++) {\n      if (objStack[i] === obj) {\n        throw new TypeError(\"Converting circular structure to JSON\");\n      }\n    }\n  }\n\n  function makeIndent(str, num, noNewLine) {\n    if (!str) {\n      return \"\";\n    } // indentation no more than 10 chars\n\n\n    if (str.length > 10) {\n      str = str.substring(0, 10);\n    }\n\n    var indent = noNewLine ? \"\" : \"\\n\";\n\n    for (var i = 0; i < num; i++) {\n      indent += str;\n    }\n\n    return indent;\n  }\n\n  var indentStr;\n\n  if (space) {\n    if (typeof space === \"string\") {\n      indentStr = space;\n    } else if (typeof space === \"number\" && space >= 0) {\n      indentStr = makeIndent(\" \", space, true);\n    } else {// ignore space parameter\n    }\n  } // Copied from Crokford's implementation of JSON\n  // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n  // Begin\n\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      meta = {\n    // table of character substitutions\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"': '\\\\\"',\n    '\\\\': '\\\\\\\\'\n  };\n\n  function escapeString(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n      var c = meta[a];\n      return typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n  } // End\n\n\n  function internalStringify(holder, key, isTopLevel) {\n    var buffer, res; // Replace the value, if necessary\n\n    var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n    if (obj_part && !isDate(obj_part)) {\n      // unbox objects\n      // don't unbox dates, since will turn it into number\n      obj_part = obj_part.valueOf();\n    }\n\n    switch (typeof obj_part) {\n      case \"boolean\":\n        return obj_part.toString();\n\n      case \"number\":\n        if (isNaN(obj_part) || !isFinite(obj_part)) {\n          return \"null\";\n        }\n\n        return obj_part.toString();\n\n      case \"string\":\n        return escapeString(obj_part.toString());\n\n      case \"object\":\n        if (obj_part === null) {\n          return \"null\";\n        } else if (isArray(obj_part)) {\n          checkForCircular(obj_part);\n          buffer = \"[\";\n          objStack.push(obj_part);\n\n          for (var i = 0; i < obj_part.length; i++) {\n            res = internalStringify(obj_part, i, false);\n            buffer += makeIndent(indentStr, objStack.length);\n\n            if (res === null || typeof res === \"undefined\") {\n              buffer += \"null\";\n            } else {\n              buffer += res;\n            }\n\n            if (i < obj_part.length - 1) {\n              buffer += \",\";\n            } else if (indentStr) {\n              buffer += \"\\n\";\n            }\n          }\n\n          objStack.pop();\n          buffer += makeIndent(indentStr, objStack.length, true) + \"]\";\n        } else {\n          checkForCircular(obj_part);\n          buffer = \"{\";\n          var nonEmpty = false;\n          objStack.push(obj_part);\n\n          for (var prop in obj_part) {\n            if (obj_part.hasOwnProperty(prop)) {\n              var value = internalStringify(obj_part, prop, false);\n              isTopLevel = false;\n\n              if (typeof value !== \"undefined\" && value !== null) {\n                buffer += makeIndent(indentStr, objStack.length);\n                nonEmpty = true;\n                var key = isWord(prop) ? prop : escapeString(prop);\n                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n              }\n            }\n          }\n\n          objStack.pop();\n\n          if (nonEmpty) {\n            buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + \"}\";\n          } else {\n            buffer = '{}';\n          }\n        }\n\n        return buffer;\n\n      default:\n        // functions and undefined should be ignored\n        return undefined;\n    }\n  } // special case...when undefined is used inside of\n  // a compound object/array, return null.\n  // but when top-level, return undefined\n\n\n  var topLevelHolder = {\n    \"\": obj\n  };\n\n  if (obj === undefined) {\n    return getReplacedValueOrUndefined(topLevelHolder, '', true);\n  }\n\n  return internalStringify(topLevelHolder, '', true);\n};","map":{"version":3,"sources":["/Users/samianki/node_modules/pm2/lib/tools/json5.js"],"names":["JSON5","exports","parse","at","ch","escapee","b","f","n","r","t","ws","text","error","m","SyntaxError","message","next","c","charAt","peek","identifier","key","number","sign","string","base","word","isNaN","isFinite","hex","i","delim","uffff","parseInt","String","fromCharCode","inlineComment","blockComment","comment","white","indexOf","Infinity","NaN","value","array","push","object","source","reviver","result","walk","holder","k","v","Object","prototype","hasOwnProperty","call","undefined","stringify","obj","replacer","space","isArray","Error","getReplacedValueOrUndefined","isTopLevel","toJSON","isWordChar","char","isWordStart","isWord","length","Array","toString","isDate","val","objStack","checkForCircular","TypeError","makeIndent","str","num","noNewLine","substring","indent","indentStr","cx","escapable","meta","escapeString","lastIndex","test","replace","a","charCodeAt","slice","internalStringify","buffer","res","obj_part","valueOf","pop","nonEmpty","prop","topLevelHolder"],"mappings":"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","sourcesContent":["// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n\nvar JSON5 = (typeof exports === 'object' ? exports : {});\n\nJSON5.parse = (function () {\n    \"use strict\";\n\n// This is a function that can parse a JSON5 text, producing a JavaScript\n// data structure. It is a simple, recursive descent parser. It does not use\n// eval or regular expressions, so it can be used as a model for implementing\n// a JSON5 parser in other languages.\n\n// We are defining the function inside of another function to avoid creating\n// global variables.\n\n    var at,     // The index of the current character\n        ch,     // The current character\n        escapee = {\n            \"'\":  \"'\",\n            '\"':  '\"',\n            '\\\\': '\\\\',\n            '/':  '/',\n            '\\n': '',       // Replace escaped newlines in strings w/ empty string\n            b:    '\\b',\n            f:    '\\f',\n            n:    '\\n',\n            r:    '\\r',\n            t:    '\\t'\n        },\n        ws = [\n            ' ',\n            '\\t',\n            '\\r',\n            '\\n',\n            '\\v',\n            '\\f',\n            '\\xA0',\n            '\\uFEFF'\n        ],\n        text,\n\n        error = function (m) {\n\n// Call error when something is wrong.\n\n            var error = new SyntaxError();\n            error.message = m;\n            error.at = at;\n            error.text = text;\n            throw error;\n        },\n\n        next = function (c) {\n\n// If a c parameter is provided, verify that it matches the current character.\n\n            if (c && c !== ch) {\n                error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n            }\n\n// Get the next character. When there are no more characters,\n// return the empty string.\n\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n\n        peek = function () {\n\n// Get the next character without consuming it or\n// assigning it to the ch varaible.\n\n            return text.charAt(at);\n        },\n\n        identifier = function () {\n\n// Parse an identifier. Normally, reserved words are disallowed here, but we\n// only use this for unquoted object keys, where reserved words are allowed,\n// so we don't check for those here. References:\n// - http://es5.github.com/#x7.6\n// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n\n            var key = ch;\n\n            // Identifiers must start with a letter, _ or $.\n            if ((ch !== '_' && ch !== '$') &&\n                    (ch < 'a' || ch > 'z') &&\n                    (ch < 'A' || ch > 'Z')) {\n                error(\"Bad identifier\");\n            }\n\n            // Subsequent characters can contain digits.\n            while (next() && (\n                    ch === '_' || ch === '$' ||\n                    (ch >= 'a' && ch <= 'z') ||\n                    (ch >= 'A' && ch <= 'Z') ||\n                    (ch >= '0' && ch <= '9'))) {\n                key += ch;\n            }\n\n            return key;\n        },\n\n        number = function () {\n\n// Parse a number value.\n\n            var number,\n                sign = '',\n                string = '',\n                base = 10;\n\n            if (ch === '-' || ch === '+') {\n                sign = ch;\n                next(ch);\n            }\n\n            // support for Infinity (could tweak to allow other words):\n            if (ch === 'I') {\n                number = word();\n                if (typeof number !== 'number' || isNaN(number)) {\n                    error('Unexpected word for number');\n                }\n                return (sign === '-') ? -number : number;\n            }\n\n            // support for NaN\n            if (ch === 'N' ) {\n              number = word();\n              if (!isNaN(number)) {\n                error('expected word to be NaN');\n              }\n              // ignore sign as -NaN also is NaN\n              return number;\n            }\n\n            if (ch === '0') {\n                string += ch;\n                next();\n                if (ch === 'x' || ch === 'X') {\n                    string += ch;\n                    next();\n                    base = 16;\n                } else if (ch >= '0' && ch <= '9') {\n                    error('Octal literal');\n                }\n            }\n\n            switch (base) {\n            case 10:\n                while (ch >= '0' && ch <= '9' ) {\n                    string += ch;\n                    next();\n                }\n                if (ch === '.') {\n                    string += '.';\n                    while (next() && ch >= '0' && ch <= '9') {\n                        string += ch;\n                    }\n                }\n                if (ch === 'e' || ch === 'E') {\n                    string += ch;\n                    next();\n                    if (ch === '-' || ch === '+') {\n                        string += ch;\n                        next();\n                    }\n                    while (ch >= '0' && ch <= '9') {\n                        string += ch;\n                        next();\n                    }\n                }\n                break;\n            case 16:\n                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n                    string += ch;\n                    next();\n                }\n                break;\n            }\n\n            if(sign === '-') {\n                number = -string;\n            } else {\n                number = +string;\n            }\n\n            if (!isFinite(number)) {\n                error(\"Bad number\");\n            } else {\n                return number;\n            }\n        },\n\n        string = function () {\n\n// Parse a string value.\n\n            var hex,\n                i,\n                string = '',\n                delim,      // double quote or single quote\n                uffff;\n\n// When parsing for string values, we must look for ' or \" and \\ characters.\n\n            if (ch === '\"' || ch === \"'\") {\n                delim = ch;\n                while (next()) {\n                    if (ch === delim) {\n                        next();\n                        return string;\n                    } else if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (ch === '\\r') {\n                            if (peek() === '\\n') {\n                                next();\n                            }\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else if (ch === '\\n') {\n                        // unescaped newlines are invalid; see:\n                        // https://github.com/aseemk/json5/issues/24\n                        // invalid unescaped chars?\n                        break;\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error(\"Bad string\");\n        },\n\n        inlineComment = function () {\n\n// Skip an inline comment, assuming this is one. The current character should\n// be the second / character in the // pair that begins this inline comment.\n// To finish the inline comment, we look for a newline or the end of the text.\n\n            if (ch !== '/') {\n                error(\"Not an inline comment\");\n            }\n\n            do {\n                next();\n                if (ch === '\\n' || ch === '\\r') {\n                    next();\n                    return;\n                }\n            } while (ch);\n        },\n\n        blockComment = function () {\n\n// Skip a block comment, assuming this is one. The current character should be\n// the * character in the /* pair that begins this block comment.\n// To finish the block comment, we look for an ending */ pair of characters,\n// but we also watch for the end of text before the comment is terminated.\n\n            if (ch !== '*') {\n                error(\"Not a block comment\");\n            }\n\n            do {\n                next();\n                while (ch === '*') {\n                    next('*');\n                    if (ch === '/') {\n                        next('/');\n                        return;\n                    }\n                }\n            } while (ch);\n\n            error(\"Unterminated block comment\");\n        },\n\n        comment = function () {\n\n// Skip a comment, whether inline or block-level, assuming this is one.\n// Comments always begin with a / character.\n\n            if (ch !== '/') {\n                error(\"Not a comment\");\n            }\n\n            next('/');\n\n            if (ch === '/') {\n                inlineComment();\n            } else if (ch === '*') {\n                blockComment();\n            } else {\n                error(\"Unrecognized comment\");\n            }\n        },\n\n        white = function () {\n\n// Skip whitespace and comments.\n// Note that we're detecting comments by only a single / character.\n// This works since regular expressions are not valid JSON(5), but this will\n// break if there are other valid values that begin with a / character!\n\n            while (ch) {\n                if (ch === '/') {\n                    comment();\n                } else if (ws.indexOf(ch) >= 0) {\n                    next();\n                } else {\n                    return;\n                }\n            }\n        },\n\n        word = function () {\n\n// true, false, or null.\n\n            switch (ch) {\n            case 't':\n                next('t');\n                next('r');\n                next('u');\n                next('e');\n                return true;\n            case 'f':\n                next('f');\n                next('a');\n                next('l');\n                next('s');\n                next('e');\n                return false;\n            case 'n':\n                next('n');\n                next('u');\n                next('l');\n                next('l');\n                return null;\n            case 'I':\n                next('I');\n                next('n');\n                next('f');\n                next('i');\n                next('n');\n                next('i');\n                next('t');\n                next('y');\n                return Infinity;\n            case 'N':\n              next( 'N' );\n              next( 'a' );\n              next( 'N' );\n              return NaN;\n            }\n            error(\"Unexpected '\" + ch + \"'\");\n        },\n\n        value,  // Place holder for the value function.\n\n        array = function () {\n\n// Parse an array value.\n\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                while (ch) {\n                    if (ch === ']') {\n                        next(']');\n                        return array;   // Potentially empty array\n                    }\n                    // ES5 allows omitting elements in arrays, e.g. [,] and\n                    // [,null]. We don't allow this in JSON5.\n                    if (ch === ',') {\n                        error(\"Missing array element\");\n                    } else {\n                        array.push(value());\n                    }\n                    white();\n                    // If there's no comma after this value, this needs to\n                    // be the end of the array.\n                    if (ch !== ',') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad array\");\n        },\n\n        object = function () {\n\n// Parse an object value.\n\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                while (ch) {\n                    if (ch === '}') {\n                        next('}');\n                        return object;   // Potentially empty object\n                    }\n\n                    // Keys can be unquoted. If they are, they need to be\n                    // valid JS identifiers.\n                    if (ch === '\"' || ch === \"'\") {\n                        key = string();\n                    } else {\n                        key = identifier();\n                    }\n\n                    white();\n                    next(':');\n                    object[key] = value();\n                    white();\n                    // If there's no comma after this pair, this needs to be\n                    // the end of the object.\n                    if (ch !== ',') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad object\");\n        };\n\n    value = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n        white();\n        switch (ch) {\n        case '{':\n            return object();\n        case '[':\n            return array();\n        case '\"':\n        case \"'\":\n            return string();\n        case '-':\n        case '+':\n        case '.':\n            return number();\n        default:\n            return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\n    return function (source, reviver) {\n        var result;\n\n        text = String(source);\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n\n// If there is a reviver function, we recursively walk the new structure,\n// passing each name/value pair to the reviver function for possible\n// transformation, starting with a temporary root object that holds the result\n// in an empty key. If there is not a reviver function, we simply return the\n// result.\n\n        return typeof reviver === 'function' ? (function walk(holder, key) {\n            var k, v, value = holder[key];\n            if (value && typeof value === 'object') {\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = walk(value, k);\n                        if (v !== undefined) {\n                            value[k] = v;\n                        } else {\n                            delete value[k];\n                        }\n                    }\n                }\n            }\n            return reviver.call(holder, key, value);\n        }({'': result}, '')) : result;\n    };\n}());\n\n// JSON5 stringify will not quote keys where appropriate\nJSON5.stringify = function (obj, replacer, space) {\n    if (replacer && (typeof(replacer) !== \"function\" && !isArray(replacer))) {\n        throw new Error('Replacer must be a function or an array');\n    }\n    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {\n        var value = holder[key];\n\n        // Replace the value with its toJSON value first, if possible\n        if (value && value.toJSON && typeof value.toJSON === \"function\") {\n            value = value.toJSON();\n        }\n\n        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n        if (typeof(replacer) === \"function\") {\n            return replacer.call(holder, key, value);\n        } else if(replacer) {\n            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n                return value;\n            } else {\n                return undefined;\n            }\n        } else {\n            return value;\n        }\n    };\n\n    function isWordChar(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            (char >= '0' && char <= '9') ||\n            char === '_' || char === '$';\n    }\n\n    function isWordStart(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            char === '_' || char === '$';\n    }\n\n    function isWord(key) {\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (!isWordStart(key[0])) {\n            return false;\n        }\n        var i = 1, length = key.length;\n        while (i < length) {\n            if (!isWordChar(key[i])) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n    // export for use in tests\n    JSON5.isWord = isWord;\n\n    // polyfills\n    function isArray(obj) {\n        if (Array.isArray) {\n            return Array.isArray(obj);\n        } else {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        }\n    }\n\n    function isDate(obj) {\n        return Object.prototype.toString.call(obj) === '[object Date]';\n    }\n\n    isNaN = isNaN || function(val) {\n        return typeof val === 'number' && val !== val;\n    };\n\n    var objStack = [];\n    function checkForCircular(obj) {\n        for (var i = 0; i < objStack.length; i++) {\n            if (objStack[i] === obj) {\n                throw new TypeError(\"Converting circular structure to JSON\");\n            }\n        }\n    }\n\n    function makeIndent(str, num, noNewLine) {\n        if (!str) {\n            return \"\";\n        }\n        // indentation no more than 10 chars\n        if (str.length > 10) {\n            str = str.substring(0, 10);\n        }\n\n        var indent = noNewLine ? \"\" : \"\\n\";\n        for (var i = 0; i < num; i++) {\n            indent += str;\n        }\n\n        return indent;\n    }\n\n    var indentStr;\n    if (space) {\n        if (typeof space === \"string\") {\n            indentStr = space;\n        } else if (typeof space === \"number\" && space >= 0) {\n            indentStr = makeIndent(\" \", space, true);\n        } else {\n            // ignore space parameter\n        }\n    }\n\n    // Copied from Crokford's implementation of JSON\n    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n    // Begin\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        meta = { // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    };\n    function escapeString(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string' ?\n                c :\n                '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n    // End\n\n    function internalStringify(holder, key, isTopLevel) {\n        var buffer, res;\n\n        // Replace the value, if necessary\n        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n        if (obj_part && !isDate(obj_part)) {\n            // unbox objects\n            // don't unbox dates, since will turn it into number\n            obj_part = obj_part.valueOf();\n        }\n        switch(typeof obj_part) {\n            case \"boolean\":\n                return obj_part.toString();\n\n            case \"number\":\n                if (isNaN(obj_part) || !isFinite(obj_part)) {\n                    return \"null\";\n                }\n                return obj_part.toString();\n\n            case \"string\":\n                return escapeString(obj_part.toString());\n\n            case \"object\":\n                if (obj_part === null) {\n                    return \"null\";\n                } else if (isArray(obj_part)) {\n                    checkForCircular(obj_part);\n                    buffer = \"[\";\n                    objStack.push(obj_part);\n\n                    for (var i = 0; i < obj_part.length; i++) {\n                        res = internalStringify(obj_part, i, false);\n                        buffer += makeIndent(indentStr, objStack.length);\n                        if (res === null || typeof res === \"undefined\") {\n                            buffer += \"null\";\n                        } else {\n                            buffer += res;\n                        }\n                        if (i < obj_part.length-1) {\n                            buffer += \",\";\n                        } else if (indentStr) {\n                            buffer += \"\\n\";\n                        }\n                    }\n                    objStack.pop();\n                    buffer += makeIndent(indentStr, objStack.length, true) + \"]\";\n                } else {\n                    checkForCircular(obj_part);\n                    buffer = \"{\";\n                    var nonEmpty = false;\n                    objStack.push(obj_part);\n                    for (var prop in obj_part) {\n                        if (obj_part.hasOwnProperty(prop)) {\n                            var value = internalStringify(obj_part, prop, false);\n                            isTopLevel = false;\n                            if (typeof value !== \"undefined\" && value !== null) {\n                                buffer += makeIndent(indentStr, objStack.length);\n                                nonEmpty = true;\n                                var key = isWord(prop) ? prop : escapeString(prop);\n                                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n                            }\n                        }\n                    }\n                    objStack.pop();\n                    if (nonEmpty) {\n                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + \"}\";\n                    } else {\n                        buffer = '{}';\n                    }\n                }\n                return buffer;\n            default:\n                // functions and undefined should be ignored\n                return undefined;\n        }\n    }\n\n    // special case...when undefined is used inside of\n    // a compound object/array, return null.\n    // but when top-level, return undefined\n    var topLevelHolder = {\"\":obj};\n    if (obj === undefined) {\n        return getReplacedValueOrUndefined(topLevelHolder, '', true);\n    }\n    return internalStringify(topLevelHolder, '', true);\n};\n"]},"metadata":{},"sourceType":"script"}