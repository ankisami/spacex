{"ast":null,"code":"var os = require('os');\n\nvar fs = require('fs');\n\nvar exec = require('child_process').exec;\n\nvar parallel = require('./parallel');\n/**\n * Gathers Clock, PageSize and system uptime through /proc/uptime\n * This method is mocked in procfile tests\n */\n\n\nfunction updateCpu(cpu, next) {\n  if (cpu !== null) {\n    getRealUptime(function (err, uptime) {\n      if (err) return next(err);\n      cpu.uptime = uptime;\n      next(null, cpu);\n    });\n    return;\n  }\n\n  parallel([getClockAndPageSize, getRealUptime], function (err, data) {\n    if (err) return next(err);\n    cpu = {\n      clockTick: data[0].clockTick,\n      pageSize: data[0].pageSize,\n      uptime: data[1]\n    };\n    next(null, cpu);\n  });\n}\n\nmodule.exports = updateCpu;\n/**\n * Fallback on os.uptime(), though /proc/uptime is more precise\n */\n\nfunction getRealUptime(next) {\n  fs.readFile('/proc/uptime', 'utf8', function (err, uptime) {\n    if (err || uptime === undefined) {\n      console.warn(\"[pidusage] We couldn't find uptime from /proc/uptime, using os.uptime() value\");\n      return next(null, os.uptime());\n    }\n\n    return next(null, parseFloat(uptime.split(' ')[0]));\n  });\n}\n\nfunction getClockAndPageSize(next) {\n  parallel([function getClockTick(cb) {\n    getconf('CLK_TCK', {\n      default: 100\n    }, cb);\n  }, function getPageSize(cb) {\n    getconf('PAGESIZE', {\n      default: 4096\n    }, cb);\n  }], function (err, data) {\n    if (err) return next(err);\n    next(null, {\n      clockTick: data[0],\n      pageSize: data[1]\n    });\n  });\n}\n\nfunction getconf(keyword, options, next) {\n  if (typeof options === 'function') {\n    next = options;\n    options = {\n      default: ''\n    };\n  }\n\n  exec('getconf ' + keyword, function (error, stdout, stderr) {\n    if (error !== null) {\n      console.error('Error while getting ' + keyword, error);\n      return next(null, options.default);\n    }\n\n    stdout = parseInt(stdout);\n\n    if (!isNaN(stdout)) {\n      return next(null, stdout);\n    }\n\n    return next(null, options.default);\n  });\n}","map":{"version":3,"sources":["/Users/samianki/node_modules/pidusage/lib/helpers/cpu.js"],"names":["os","require","fs","exec","parallel","updateCpu","cpu","next","getRealUptime","err","uptime","getClockAndPageSize","data","clockTick","pageSize","module","exports","readFile","undefined","console","warn","parseFloat","split","getClockTick","cb","getconf","default","getPageSize","keyword","options","error","stdout","stderr","parseInt","isNaN"],"mappings":"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","sourcesContent":["var os = require('os')\nvar fs = require('fs')\nvar exec = require('child_process').exec\nvar parallel = require('./parallel')\n\n/**\n * Gathers Clock, PageSize and system uptime through /proc/uptime\n * This method is mocked in procfile tests\n */\nfunction updateCpu (cpu, next) {\n  if (cpu !== null) {\n    getRealUptime(function (err, uptime) {\n      if (err) return next(err)\n      cpu.uptime = uptime\n      next(null, cpu)\n    })\n    return\n  }\n\n  parallel([\n    getClockAndPageSize,\n    getRealUptime\n  ], function (err, data) {\n    if (err) return next(err)\n\n    cpu = {\n      clockTick: data[0].clockTick,\n      pageSize: data[0].pageSize,\n      uptime: data[1]\n    }\n\n    next(null, cpu)\n  })\n}\n\nmodule.exports = updateCpu\n\n/**\n * Fallback on os.uptime(), though /proc/uptime is more precise\n */\nfunction getRealUptime (next) {\n  fs.readFile('/proc/uptime', 'utf8', function (err, uptime) {\n    if (err || uptime === undefined) {\n      console.warn(\"[pidusage] We couldn't find uptime from /proc/uptime, using os.uptime() value\")\n      return next(null, os.uptime())\n    }\n\n    return next(null, parseFloat(uptime.split(' ')[0]))\n  })\n}\n\nfunction getClockAndPageSize (next) {\n  parallel([\n    function getClockTick (cb) {\n      getconf('CLK_TCK', { default: 100 }, cb)\n    },\n    function getPageSize (cb) {\n      getconf('PAGESIZE', { default: 4096 }, cb)\n    }\n  ], function (err, data) {\n    if (err) return next(err)\n\n    next(null, { clockTick: data[0], pageSize: data[1] })\n  })\n}\n\nfunction getconf (keyword, options, next) {\n  if (typeof options === 'function') {\n    next = options\n    options = { default: '' }\n  }\n\n  exec('getconf ' + keyword, function (error, stdout, stderr) {\n    if (error !== null) {\n      console.error('Error while getting ' + keyword, error)\n      return next(null, options.default)\n    }\n\n    stdout = parseInt(stdout)\n\n    if (!isNaN(stdout)) {\n      return next(null, stdout)\n    }\n\n    return next(null, options.default)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}