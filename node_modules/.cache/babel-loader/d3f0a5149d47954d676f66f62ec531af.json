{"ast":null,"code":"'use strict';\n\nconst Events = require('events');\n\nconst colors = require('ansi-colors');\n\nconst keypress = require('./keypress');\n\nconst timer = require('./timer');\n\nconst State = require('./state');\n\nconst theme = require('./theme');\n\nconst utils = require('./utils');\n\nconst ansi = require('./ansi');\n/**\n * Base class for creating a new Prompt.\n * @param {Object} `options` Question object.\n */\n\n\nclass Prompt extends Events {\n  constructor(options = {}) {\n    super();\n    this.name = options.name;\n    this.type = options.type;\n    this.options = options;\n    theme(this);\n    timer(this);\n    this.state = new State(this);\n    this.initial = [options.initial, options.default].find(v => v != null);\n    this.stdout = options.stdout || process.stdout;\n    this.stdin = options.stdin || process.stdin;\n    this.scale = options.scale || 1;\n    this.term = this.options.term || process.env.TERM_PROGRAM;\n    this.margin = margin(this.options.margin);\n    this.setMaxListeners(0);\n    setOptions(this);\n  }\n\n  async keypress(input, event = {}) {\n    this.keypressed = true;\n    let key = keypress.action(input, keypress(input, event), this.options.actions);\n    this.state.keypress = key;\n    this.emit('keypress', input, key);\n    this.emit('state', this.state.clone());\n    let fn = this.options[key.action] || this[key.action] || this.dispatch;\n\n    if (typeof fn === 'function') {\n      return await fn.call(this, input, key);\n    }\n\n    this.alert();\n  }\n\n  alert() {\n    delete this.state.alert;\n\n    if (this.options.show === false) {\n      this.emit('alert');\n    } else {\n      this.stdout.write(ansi.code.beep);\n    }\n  }\n\n  cursorHide() {\n    this.stdout.write(ansi.cursor.hide());\n    utils.onExit(() => this.cursorShow());\n  }\n\n  cursorShow() {\n    this.stdout.write(ansi.cursor.show());\n  }\n\n  write(str) {\n    if (!str) return;\n\n    if (this.stdout && this.state.show !== false) {\n      this.stdout.write(str);\n    }\n\n    this.state.buffer += str;\n  }\n\n  clear(lines = 0) {\n    let buffer = this.state.buffer;\n    this.state.buffer = '';\n    if (!buffer && !lines || this.options.show === false) return;\n    this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));\n  }\n\n  restore() {\n    if (this.state.closed || this.options.show === false) return;\n    let {\n      prompt,\n      after,\n      rest\n    } = this.sections();\n    let {\n      cursor,\n      initial = '',\n      input = '',\n      value = ''\n    } = this;\n    let size = this.state.size = rest.length;\n    let state = {\n      after,\n      cursor,\n      initial,\n      input,\n      prompt,\n      size,\n      value\n    };\n    let codes = ansi.cursor.restore(state);\n\n    if (codes) {\n      this.stdout.write(codes);\n    }\n  }\n\n  sections() {\n    let {\n      buffer,\n      input,\n      prompt\n    } = this.state;\n    prompt = colors.unstyle(prompt);\n    let buf = colors.unstyle(buffer);\n    let idx = buf.indexOf(prompt);\n    let header = buf.slice(0, idx);\n    let rest = buf.slice(idx);\n    let lines = rest.split('\\n');\n    let first = lines[0];\n    let last = lines[lines.length - 1];\n    let promptLine = prompt + (input ? ' ' + input : '');\n    let len = promptLine.length;\n    let after = len < first.length ? first.slice(len + 1) : '';\n    return {\n      header,\n      prompt: first,\n      after,\n      rest: lines.slice(1),\n      last\n    };\n  }\n\n  async submit() {\n    this.state.submitted = true;\n    this.state.validating = true; // this will only be called when the prompt is directly submitted\n    // without initializing, i.e. when the prompt is skipped, etc. Otherwize,\n    // \"options.onSubmit\" is will be handled by the \"initialize()\" method.\n\n    if (this.options.onSubmit) {\n      await this.options.onSubmit.call(this, this.name, this.value, this);\n    }\n\n    let result = this.state.error || (await this.validate(this.value, this.state));\n\n    if (result !== true) {\n      let error = '\\n' + this.symbols.pointer + ' ';\n\n      if (typeof result === 'string') {\n        error += result.trim();\n      } else {\n        error += 'Invalid input';\n      }\n\n      this.state.error = '\\n' + this.styles.danger(error);\n      this.state.submitted = false;\n      await this.render();\n      await this.alert();\n      this.state.validating = false;\n      this.state.error = void 0;\n      return;\n    }\n\n    this.state.validating = false;\n    await this.render();\n    await this.close();\n    this.value = await this.result(this.value);\n    this.emit('submit', this.value);\n  }\n\n  async cancel(err) {\n    this.state.cancelled = this.state.submitted = true;\n    await this.render();\n    await this.close();\n\n    if (typeof this.options.onCancel === 'function') {\n      await this.options.onCancel.call(this, this.name, this.value, this);\n    }\n\n    this.emit('cancel', await this.error(err));\n  }\n\n  async close() {\n    this.state.closed = true;\n\n    try {\n      let sections = this.sections();\n      let lines = Math.ceil(sections.prompt.length / this.width);\n\n      if (sections.rest) {\n        this.write(ansi.cursor.down(sections.rest.length));\n      }\n\n      this.write('\\n'.repeat(lines));\n    } catch (err) {\n      /* do nothing */\n    }\n\n    this.emit('close');\n  }\n\n  start() {\n    if (!this.stop && this.options.show !== false) {\n      this.stop = keypress.listen(this, this.keypress.bind(this));\n      this.once('close', this.stop);\n    }\n  }\n\n  async skip() {\n    this.skipped = this.options.skip === true;\n\n    if (typeof this.options.skip === 'function') {\n      this.skipped = await this.options.skip.call(this, this.name, this.value);\n    }\n\n    return this.skipped;\n  }\n\n  async initialize() {\n    let {\n      format,\n      options,\n      result\n    } = this;\n\n    this.format = () => format.call(this, this.value);\n\n    this.result = () => result.call(this, this.value);\n\n    if (typeof options.initial === 'function') {\n      this.initial = await options.initial.call(this, this);\n    }\n\n    if (typeof options.onRun === 'function') {\n      await options.onRun.call(this, this);\n    } // if \"options.onSubmit\" is defined, we wrap the \"submit\" method to guarantee\n    // that \"onSubmit\" will always called first thing inside the submit\n    // method, regardless of how it's handled in inheriting prompts.\n\n\n    if (typeof options.onSubmit === 'function') {\n      let onSubmit = options.onSubmit.bind(this);\n      let submit = this.submit.bind(this);\n      delete this.options.onSubmit;\n\n      this.submit = async () => {\n        await onSubmit(this.name, this.value, this);\n        return submit();\n      };\n    }\n\n    await this.start();\n    await this.render();\n  }\n\n  render() {\n    throw new Error('expected prompt to have a custom render method');\n  }\n\n  run() {\n    return new Promise(async (resolve, reject) => {\n      this.once('submit', resolve);\n      this.once('cancel', reject);\n\n      if (await this.skip()) {\n        this.render = () => {};\n\n        return this.submit();\n      }\n\n      await this.initialize();\n      this.emit('run');\n    });\n  }\n\n  async element(name, choice, i) {\n    let {\n      options,\n      state,\n      symbols,\n      timers\n    } = this;\n    let timer = timers && timers[name];\n    state.timer = timer;\n    let value = options[name] || state[name] || symbols[name];\n    let val = choice && choice[name] != null ? choice[name] : await value;\n    if (val === '') return val;\n    let res = await this.resolve(val, state, choice, i);\n\n    if (!res && choice && choice[name]) {\n      return this.resolve(value, state, choice, i);\n    }\n\n    return res;\n  }\n\n  async prefix() {\n    let element = (await this.element('prefix')) || this.symbols;\n    let timer = this.timers && this.timers.prefix;\n    let state = this.state;\n    state.timer = timer;\n    if (utils.isObject(element)) element = element[state.status] || element.pending;\n\n    if (!utils.hasColor(element)) {\n      let style = this.styles[state.status] || this.styles.pending;\n      return style(element);\n    }\n\n    return element;\n  }\n\n  async message() {\n    let message = await this.element('message');\n\n    if (!utils.hasColor(message)) {\n      return this.styles.strong(message);\n    }\n\n    return message;\n  }\n\n  async separator() {\n    let element = (await this.element('separator')) || this.symbols;\n    let timer = this.timers && this.timers.separator;\n    let state = this.state;\n    state.timer = timer;\n    let value = element[state.status] || element.pending || state.separator;\n    let ele = await this.resolve(value, state);\n    if (utils.isObject(ele)) ele = ele[state.status] || ele.pending;\n\n    if (!utils.hasColor(ele)) {\n      return this.styles.muted(ele);\n    }\n\n    return ele;\n  }\n\n  async pointer(choice, i) {\n    let val = await this.element('pointer', choice, i);\n\n    if (typeof val === 'string' && utils.hasColor(val)) {\n      return val;\n    }\n\n    if (val) {\n      let styles = this.styles;\n      let focused = this.index === i;\n      let style = focused ? styles.primary : val => val;\n      let ele = await this.resolve(val[focused ? 'on' : 'off'] || val, this.state);\n      let styled = !utils.hasColor(ele) ? style(ele) : ele;\n      return focused ? styled : ' '.repeat(ele.length);\n    }\n  }\n\n  async indicator(choice, i) {\n    let val = await this.element('indicator', choice, i);\n\n    if (typeof val === 'string' && utils.hasColor(val)) {\n      return val;\n    }\n\n    if (val) {\n      let styles = this.styles;\n      let enabled = choice.enabled === true;\n      let style = enabled ? styles.success : styles.dark;\n      let ele = val[enabled ? 'on' : 'off'] || val;\n      return !utils.hasColor(ele) ? style(ele) : ele;\n    }\n\n    return '';\n  }\n\n  body() {\n    return null;\n  }\n\n  footer() {\n    if (this.state.status === 'pending') {\n      return this.element('footer');\n    }\n  }\n\n  header() {\n    if (this.state.status === 'pending') {\n      return this.element('header');\n    }\n  }\n\n  async hint() {\n    if (this.state.status === 'pending' && !this.isValue(this.state.input)) {\n      let hint = await this.element('hint');\n\n      if (!utils.hasColor(hint)) {\n        return this.styles.muted(hint);\n      }\n\n      return hint;\n    }\n  }\n\n  error(err) {\n    return !this.state.submitted ? err || this.state.error : '';\n  }\n\n  format(value) {\n    return value;\n  }\n\n  result(value) {\n    return value;\n  }\n\n  validate(value) {\n    if (this.options.required === true) {\n      return this.isValue(value);\n    }\n\n    return true;\n  }\n\n  isValue(value) {\n    return value != null && value !== '';\n  }\n\n  resolve(value, ...args) {\n    return utils.resolve(this, value, ...args);\n  }\n\n  get base() {\n    return Prompt.prototype;\n  }\n\n  get style() {\n    return this.styles[this.state.status];\n  }\n\n  get height() {\n    return this.options.rows || utils.height(this.stdout, 25);\n  }\n\n  get width() {\n    return this.options.columns || utils.width(this.stdout, 80);\n  }\n\n  get size() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  set cursor(value) {\n    this.state.cursor = value;\n  }\n\n  get cursor() {\n    return this.state.cursor;\n  }\n\n  set input(value) {\n    this.state.input = value;\n  }\n\n  get input() {\n    return this.state.input;\n  }\n\n  set value(value) {\n    this.state.value = value;\n  }\n\n  get value() {\n    let {\n      input,\n      value\n    } = this.state;\n    let result = [value, input].find(this.isValue.bind(this));\n    return this.isValue(result) ? result : this.initial;\n  }\n\n  static get prompt() {\n    return options => new this(options).run();\n  }\n\n}\n\nfunction setOptions(prompt) {\n  let isValidKey = key => {\n    return prompt[key] === void 0 || typeof prompt[key] === 'function';\n  };\n\n  let ignore = ['actions', 'choices', 'initial', 'margin', 'roles', 'styles', 'symbols', 'theme', 'timers', 'value'];\n  let ignoreFn = ['body', 'footer', 'error', 'header', 'hint', 'indicator', 'message', 'prefix', 'separator', 'skip'];\n\n  for (let key of Object.keys(prompt.options)) {\n    if (ignore.includes(key)) continue;\n    if (/^on[A-Z]/.test(key)) continue;\n    let option = prompt.options[key];\n\n    if (typeof option === 'function' && isValidKey(key)) {\n      if (!ignoreFn.includes(key)) {\n        prompt[key] = option.bind(prompt);\n      }\n    } else if (typeof prompt[key] !== 'function') {\n      prompt[key] = option;\n    }\n  }\n}\n\nfunction margin(value) {\n  if (typeof value === 'number') {\n    value = [value, value, value, value];\n  }\n\n  let arr = [].concat(value || []);\n\n  let pad = i => i % 2 === 0 ? '\\n' : ' ';\n\n  let res = [];\n\n  for (let i = 0; i < 4; i++) {\n    let char = pad(i);\n\n    if (arr[i]) {\n      res.push(char.repeat(arr[i]));\n    } else {\n      res.push('');\n    }\n  }\n\n  return res;\n}\n\nmodule.exports = Prompt;","map":{"version":3,"sources":["/Users/samianki/node_modules/enquirer/lib/prompt.js"],"names":["Events","require","colors","keypress","timer","State","theme","utils","ansi","Prompt","constructor","options","name","type","state","initial","default","find","v","stdout","process","stdin","scale","term","env","TERM_PROGRAM","margin","setMaxListeners","setOptions","input","event","keypressed","key","action","actions","emit","clone","fn","dispatch","call","alert","show","write","code","beep","cursorHide","cursor","hide","onExit","cursorShow","str","buffer","clear","lines","down","width","restore","closed","prompt","after","rest","sections","value","size","length","codes","unstyle","buf","idx","indexOf","header","slice","split","first","last","promptLine","len","submit","submitted","validating","onSubmit","result","error","validate","symbols","pointer","trim","styles","danger","render","close","cancel","err","cancelled","onCancel","Math","ceil","repeat","start","stop","listen","bind","once","skip","skipped","initialize","format","onRun","Error","run","Promise","resolve","reject","element","choice","i","timers","val","res","prefix","isObject","status","pending","hasColor","style","message","strong","separator","ele","muted","focused","index","primary","styled","indicator","enabled","success","dark","body","footer","hint","isValue","required","args","base","prototype","height","rows","columns","isValidKey","ignore","ignoreFn","Object","keys","includes","test","option","arr","concat","pad","char","push","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMM,KAAK,GAAGN,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMO,IAAI,GAAGP,OAAO,CAAC,QAAD,CAApB;AAEA;AACA;AACA;AACA;;;AAEA,MAAMQ,MAAN,SAAqBT,MAArB,CAA4B;AAC1BU,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxB;AACA,SAAKC,IAAL,GAAYD,OAAO,CAACC,IAApB;AACA,SAAKC,IAAL,GAAYF,OAAO,CAACE,IAApB;AACA,SAAKF,OAAL,GAAeA,OAAf;AACAL,IAAAA,KAAK,CAAC,IAAD,CAAL;AACAF,IAAAA,KAAK,CAAC,IAAD,CAAL;AACA,SAAKU,KAAL,GAAa,IAAIT,KAAJ,CAAU,IAAV,CAAb;AACA,SAAKU,OAAL,GAAe,CAACJ,OAAO,CAACI,OAAT,EAAkBJ,OAAO,CAACK,OAA1B,EAAmCC,IAAnC,CAAwCC,CAAC,IAAIA,CAAC,IAAI,IAAlD,CAAf;AACA,SAAKC,MAAL,GAAcR,OAAO,CAACQ,MAAR,IAAkBC,OAAO,CAACD,MAAxC;AACA,SAAKE,KAAL,GAAaV,OAAO,CAACU,KAAR,IAAiBD,OAAO,CAACC,KAAtC;AACA,SAAKC,KAAL,GAAaX,OAAO,CAACW,KAAR,IAAiB,CAA9B;AACA,SAAKC,IAAL,GAAY,KAAKZ,OAAL,CAAaY,IAAb,IAAqBH,OAAO,CAACI,GAAR,CAAYC,YAA7C;AACA,SAAKC,MAAL,GAAcA,MAAM,CAAC,KAAKf,OAAL,CAAae,MAAd,CAApB;AACA,SAAKC,eAAL,CAAqB,CAArB;AACAC,IAAAA,UAAU,CAAC,IAAD,CAAV;AACD;;AAEa,QAARzB,QAAQ,CAAC0B,KAAD,EAAQC,KAAK,GAAG,EAAhB,EAAoB;AAChC,SAAKC,UAAL,GAAkB,IAAlB;AACA,QAAIC,GAAG,GAAG7B,QAAQ,CAAC8B,MAAT,CAAgBJ,KAAhB,EAAuB1B,QAAQ,CAAC0B,KAAD,EAAQC,KAAR,CAA/B,EAA+C,KAAKnB,OAAL,CAAauB,OAA5D,CAAV;AACA,SAAKpB,KAAL,CAAWX,QAAX,GAAsB6B,GAAtB;AACA,SAAKG,IAAL,CAAU,UAAV,EAAsBN,KAAtB,EAA6BG,GAA7B;AACA,SAAKG,IAAL,CAAU,OAAV,EAAmB,KAAKrB,KAAL,CAAWsB,KAAX,EAAnB;AACA,QAAIC,EAAE,GAAG,KAAK1B,OAAL,CAAaqB,GAAG,CAACC,MAAjB,KAA4B,KAAKD,GAAG,CAACC,MAAT,CAA5B,IAAgD,KAAKK,QAA9D;;AACA,QAAI,OAAOD,EAAP,KAAc,UAAlB,EAA8B;AAC5B,aAAO,MAAMA,EAAE,CAACE,IAAH,CAAQ,IAAR,EAAcV,KAAd,EAAqBG,GAArB,CAAb;AACD;;AACD,SAAKQ,KAAL;AACD;;AAEDA,EAAAA,KAAK,GAAG;AACN,WAAO,KAAK1B,KAAL,CAAW0B,KAAlB;;AACA,QAAI,KAAK7B,OAAL,CAAa8B,IAAb,KAAsB,KAA1B,EAAiC;AAC/B,WAAKN,IAAL,CAAU,OAAV;AACD,KAFD,MAEO;AACL,WAAKhB,MAAL,CAAYuB,KAAZ,CAAkBlC,IAAI,CAACmC,IAAL,CAAUC,IAA5B;AACD;AACF;;AAEDC,EAAAA,UAAU,GAAG;AACX,SAAK1B,MAAL,CAAYuB,KAAZ,CAAkBlC,IAAI,CAACsC,MAAL,CAAYC,IAAZ,EAAlB;AACAxC,IAAAA,KAAK,CAACyC,MAAN,CAAa,MAAM,KAAKC,UAAL,EAAnB;AACD;;AAEDA,EAAAA,UAAU,GAAG;AACX,SAAK9B,MAAL,CAAYuB,KAAZ,CAAkBlC,IAAI,CAACsC,MAAL,CAAYL,IAAZ,EAAlB;AACD;;AAEDC,EAAAA,KAAK,CAACQ,GAAD,EAAM;AACT,QAAI,CAACA,GAAL,EAAU;;AACV,QAAI,KAAK/B,MAAL,IAAe,KAAKL,KAAL,CAAW2B,IAAX,KAAoB,KAAvC,EAA8C;AAC5C,WAAKtB,MAAL,CAAYuB,KAAZ,CAAkBQ,GAAlB;AACD;;AACD,SAAKpC,KAAL,CAAWqC,MAAX,IAAqBD,GAArB;AACD;;AAEDE,EAAAA,KAAK,CAACC,KAAK,GAAG,CAAT,EAAY;AACf,QAAIF,MAAM,GAAG,KAAKrC,KAAL,CAAWqC,MAAxB;AACA,SAAKrC,KAAL,CAAWqC,MAAX,GAAoB,EAApB;AACA,QAAK,CAACA,MAAD,IAAW,CAACE,KAAb,IAAuB,KAAK1C,OAAL,CAAa8B,IAAb,KAAsB,KAAjD,EAAwD;AACxD,SAAKtB,MAAL,CAAYuB,KAAZ,CAAkBlC,IAAI,CAACsC,MAAL,CAAYQ,IAAZ,CAAiBD,KAAjB,IAA0B7C,IAAI,CAAC4C,KAAL,CAAWD,MAAX,EAAmB,KAAKI,KAAxB,CAA5C;AACD;;AAEDC,EAAAA,OAAO,GAAG;AACR,QAAI,KAAK1C,KAAL,CAAW2C,MAAX,IAAqB,KAAK9C,OAAL,CAAa8B,IAAb,KAAsB,KAA/C,EAAsD;AAEtD,QAAI;AAAEiB,MAAAA,MAAF;AAAUC,MAAAA,KAAV;AAAiBC,MAAAA;AAAjB,QAA0B,KAAKC,QAAL,EAA9B;AACA,QAAI;AAAEf,MAAAA,MAAF;AAAU/B,MAAAA,OAAO,GAAG,EAApB;AAAwBc,MAAAA,KAAK,GAAG,EAAhC;AAAoCiC,MAAAA,KAAK,GAAG;AAA5C,QAAmD,IAAvD;AAEA,QAAIC,IAAI,GAAG,KAAKjD,KAAL,CAAWiD,IAAX,GAAkBH,IAAI,CAACI,MAAlC;AACA,QAAIlD,KAAK,GAAG;AAAE6C,MAAAA,KAAF;AAASb,MAAAA,MAAT;AAAiB/B,MAAAA,OAAjB;AAA0Bc,MAAAA,KAA1B;AAAiC6B,MAAAA,MAAjC;AAAyCK,MAAAA,IAAzC;AAA+CD,MAAAA;AAA/C,KAAZ;AACA,QAAIG,KAAK,GAAGzD,IAAI,CAACsC,MAAL,CAAYU,OAAZ,CAAoB1C,KAApB,CAAZ;;AACA,QAAImD,KAAJ,EAAW;AACT,WAAK9C,MAAL,CAAYuB,KAAZ,CAAkBuB,KAAlB;AACD;AACF;;AAEDJ,EAAAA,QAAQ,GAAG;AACT,QAAI;AAAEV,MAAAA,MAAF;AAAUtB,MAAAA,KAAV;AAAiB6B,MAAAA;AAAjB,QAA4B,KAAK5C,KAArC;AACA4C,IAAAA,MAAM,GAAGxD,MAAM,CAACgE,OAAP,CAAeR,MAAf,CAAT;AACA,QAAIS,GAAG,GAAGjE,MAAM,CAACgE,OAAP,CAAef,MAAf,CAAV;AACA,QAAIiB,GAAG,GAAGD,GAAG,CAACE,OAAJ,CAAYX,MAAZ,CAAV;AACA,QAAIY,MAAM,GAAGH,GAAG,CAACI,KAAJ,CAAU,CAAV,EAAaH,GAAb,CAAb;AACA,QAAIR,IAAI,GAAGO,GAAG,CAACI,KAAJ,CAAUH,GAAV,CAAX;AACA,QAAIf,KAAK,GAAGO,IAAI,CAACY,KAAL,CAAW,IAAX,CAAZ;AACA,QAAIC,KAAK,GAAGpB,KAAK,CAAC,CAAD,CAAjB;AACA,QAAIqB,IAAI,GAAGrB,KAAK,CAACA,KAAK,CAACW,MAAN,GAAe,CAAhB,CAAhB;AACA,QAAIW,UAAU,GAAGjB,MAAM,IAAI7B,KAAK,GAAG,MAAMA,KAAT,GAAiB,EAA1B,CAAvB;AACA,QAAI+C,GAAG,GAAGD,UAAU,CAACX,MAArB;AACA,QAAIL,KAAK,GAAGiB,GAAG,GAAGH,KAAK,CAACT,MAAZ,GAAqBS,KAAK,CAACF,KAAN,CAAYK,GAAG,GAAG,CAAlB,CAArB,GAA4C,EAAxD;AACA,WAAO;AAAEN,MAAAA,MAAF;AAAUZ,MAAAA,MAAM,EAAEe,KAAlB;AAAyBd,MAAAA,KAAzB;AAAgCC,MAAAA,IAAI,EAAEP,KAAK,CAACkB,KAAN,CAAY,CAAZ,CAAtC;AAAsDG,MAAAA;AAAtD,KAAP;AACD;;AAEW,QAANG,MAAM,GAAG;AACb,SAAK/D,KAAL,CAAWgE,SAAX,GAAuB,IAAvB;AACA,SAAKhE,KAAL,CAAWiE,UAAX,GAAwB,IAAxB,CAFa,CAIb;AACA;AACA;;AACA,QAAI,KAAKpE,OAAL,CAAaqE,QAAjB,EAA2B;AACzB,YAAM,KAAKrE,OAAL,CAAaqE,QAAb,CAAsBzC,IAAtB,CAA2B,IAA3B,EAAiC,KAAK3B,IAAtC,EAA4C,KAAKkD,KAAjD,EAAwD,IAAxD,CAAN;AACD;;AAED,QAAImB,MAAM,GAAG,KAAKnE,KAAL,CAAWoE,KAAX,KAAoB,MAAM,KAAKC,QAAL,CAAc,KAAKrB,KAAnB,EAA0B,KAAKhD,KAA/B,CAA1B,CAAb;;AACA,QAAImE,MAAM,KAAK,IAAf,EAAqB;AACnB,UAAIC,KAAK,GAAG,OAAO,KAAKE,OAAL,CAAaC,OAApB,GAA8B,GAA1C;;AAEA,UAAI,OAAOJ,MAAP,KAAkB,QAAtB,EAAgC;AAC9BC,QAAAA,KAAK,IAAID,MAAM,CAACK,IAAP,EAAT;AACD,OAFD,MAEO;AACLJ,QAAAA,KAAK,IAAI,eAAT;AACD;;AAED,WAAKpE,KAAL,CAAWoE,KAAX,GAAmB,OAAO,KAAKK,MAAL,CAAYC,MAAZ,CAAmBN,KAAnB,CAA1B;AACA,WAAKpE,KAAL,CAAWgE,SAAX,GAAuB,KAAvB;AACA,YAAM,KAAKW,MAAL,EAAN;AACA,YAAM,KAAKjD,KAAL,EAAN;AACA,WAAK1B,KAAL,CAAWiE,UAAX,GAAwB,KAAxB;AACA,WAAKjE,KAAL,CAAWoE,KAAX,GAAmB,KAAK,CAAxB;AACA;AACD;;AAED,SAAKpE,KAAL,CAAWiE,UAAX,GAAwB,KAAxB;AACA,UAAM,KAAKU,MAAL,EAAN;AACA,UAAM,KAAKC,KAAL,EAAN;AAEA,SAAK5B,KAAL,GAAa,MAAM,KAAKmB,MAAL,CAAY,KAAKnB,KAAjB,CAAnB;AACA,SAAK3B,IAAL,CAAU,QAAV,EAAoB,KAAK2B,KAAzB;AACD;;AAEW,QAAN6B,MAAM,CAACC,GAAD,EAAM;AAChB,SAAK9E,KAAL,CAAW+E,SAAX,GAAuB,KAAK/E,KAAL,CAAWgE,SAAX,GAAuB,IAA9C;AAEA,UAAM,KAAKW,MAAL,EAAN;AACA,UAAM,KAAKC,KAAL,EAAN;;AAEA,QAAI,OAAO,KAAK/E,OAAL,CAAamF,QAApB,KAAiC,UAArC,EAAiD;AAC/C,YAAM,KAAKnF,OAAL,CAAamF,QAAb,CAAsBvD,IAAtB,CAA2B,IAA3B,EAAiC,KAAK3B,IAAtC,EAA4C,KAAKkD,KAAjD,EAAwD,IAAxD,CAAN;AACD;;AAED,SAAK3B,IAAL,CAAU,QAAV,EAAoB,MAAM,KAAK+C,KAAL,CAAWU,GAAX,CAA1B;AACD;;AAEU,QAALF,KAAK,GAAG;AACZ,SAAK5E,KAAL,CAAW2C,MAAX,GAAoB,IAApB;;AAEA,QAAI;AACF,UAAII,QAAQ,GAAG,KAAKA,QAAL,EAAf;AACA,UAAIR,KAAK,GAAG0C,IAAI,CAACC,IAAL,CAAUnC,QAAQ,CAACH,MAAT,CAAgBM,MAAhB,GAAyB,KAAKT,KAAxC,CAAZ;;AACA,UAAIM,QAAQ,CAACD,IAAb,EAAmB;AACjB,aAAKlB,KAAL,CAAWlC,IAAI,CAACsC,MAAL,CAAYQ,IAAZ,CAAiBO,QAAQ,CAACD,IAAT,CAAcI,MAA/B,CAAX;AACD;;AACD,WAAKtB,KAAL,CAAW,KAAKuD,MAAL,CAAY5C,KAAZ,CAAX;AACD,KAPD,CAOE,OAAOuC,GAAP,EAAY;AAAE;AAAkB;;AAElC,SAAKzD,IAAL,CAAU,OAAV;AACD;;AAED+D,EAAAA,KAAK,GAAG;AACN,QAAI,CAAC,KAAKC,IAAN,IAAc,KAAKxF,OAAL,CAAa8B,IAAb,KAAsB,KAAxC,EAA+C;AAC7C,WAAK0D,IAAL,GAAYhG,QAAQ,CAACiG,MAAT,CAAgB,IAAhB,EAAsB,KAAKjG,QAAL,CAAckG,IAAd,CAAmB,IAAnB,CAAtB,CAAZ;AACA,WAAKC,IAAL,CAAU,OAAV,EAAmB,KAAKH,IAAxB;AACD;AACF;;AAES,QAAJI,IAAI,GAAG;AACX,SAAKC,OAAL,GAAe,KAAK7F,OAAL,CAAa4F,IAAb,KAAsB,IAArC;;AACA,QAAI,OAAO,KAAK5F,OAAL,CAAa4F,IAApB,KAA6B,UAAjC,EAA6C;AAC3C,WAAKC,OAAL,GAAe,MAAM,KAAK7F,OAAL,CAAa4F,IAAb,CAAkBhE,IAAlB,CAAuB,IAAvB,EAA6B,KAAK3B,IAAlC,EAAwC,KAAKkD,KAA7C,CAArB;AACD;;AACD,WAAO,KAAK0C,OAAZ;AACD;;AAEe,QAAVC,UAAU,GAAG;AACjB,QAAI;AAAEC,MAAAA,MAAF;AAAU/F,MAAAA,OAAV;AAAmBsE,MAAAA;AAAnB,QAA8B,IAAlC;;AAEA,SAAKyB,MAAL,GAAc,MAAMA,MAAM,CAACnE,IAAP,CAAY,IAAZ,EAAkB,KAAKuB,KAAvB,CAApB;;AACA,SAAKmB,MAAL,GAAc,MAAMA,MAAM,CAAC1C,IAAP,CAAY,IAAZ,EAAkB,KAAKuB,KAAvB,CAApB;;AAEA,QAAI,OAAOnD,OAAO,CAACI,OAAf,KAA2B,UAA/B,EAA2C;AACzC,WAAKA,OAAL,GAAe,MAAMJ,OAAO,CAACI,OAAR,CAAgBwB,IAAhB,CAAqB,IAArB,EAA2B,IAA3B,CAArB;AACD;;AAED,QAAI,OAAO5B,OAAO,CAACgG,KAAf,KAAyB,UAA7B,EAAyC;AACvC,YAAMhG,OAAO,CAACgG,KAAR,CAAcpE,IAAd,CAAmB,IAAnB,EAAyB,IAAzB,CAAN;AACD,KAZgB,CAcjB;AACA;AACA;;;AACA,QAAI,OAAO5B,OAAO,CAACqE,QAAf,KAA4B,UAAhC,EAA4C;AAC1C,UAAIA,QAAQ,GAAGrE,OAAO,CAACqE,QAAR,CAAiBqB,IAAjB,CAAsB,IAAtB,CAAf;AACA,UAAIxB,MAAM,GAAG,KAAKA,MAAL,CAAYwB,IAAZ,CAAiB,IAAjB,CAAb;AACA,aAAO,KAAK1F,OAAL,CAAaqE,QAApB;;AACA,WAAKH,MAAL,GAAc,YAAW;AACvB,cAAMG,QAAQ,CAAC,KAAKpE,IAAN,EAAY,KAAKkD,KAAjB,EAAwB,IAAxB,CAAd;AACA,eAAOe,MAAM,EAAb;AACD,OAHD;AAID;;AAED,UAAM,KAAKqB,KAAL,EAAN;AACA,UAAM,KAAKT,MAAL,EAAN;AACD;;AAEDA,EAAAA,MAAM,GAAG;AACP,UAAM,IAAImB,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAEDC,EAAAA,GAAG,GAAG;AACJ,WAAO,IAAIC,OAAJ,CAAY,OAAMC,OAAN,EAAeC,MAAf,KAA0B;AAC3C,WAAKV,IAAL,CAAU,QAAV,EAAoBS,OAApB;AACA,WAAKT,IAAL,CAAU,QAAV,EAAoBU,MAApB;;AACA,UAAI,MAAM,KAAKT,IAAL,EAAV,EAAuB;AACrB,aAAKd,MAAL,GAAc,MAAM,CAAE,CAAtB;;AACA,eAAO,KAAKZ,MAAL,EAAP;AACD;;AACD,YAAM,KAAK4B,UAAL,EAAN;AACA,WAAKtE,IAAL,CAAU,KAAV;AACD,KATM,CAAP;AAUD;;AAEY,QAAP8E,OAAO,CAACrG,IAAD,EAAOsG,MAAP,EAAeC,CAAf,EAAkB;AAC7B,QAAI;AAAExG,MAAAA,OAAF;AAAWG,MAAAA,KAAX;AAAkBsE,MAAAA,OAAlB;AAA2BgC,MAAAA;AAA3B,QAAsC,IAA1C;AACA,QAAIhH,KAAK,GAAGgH,MAAM,IAAIA,MAAM,CAACxG,IAAD,CAA5B;AACAE,IAAAA,KAAK,CAACV,KAAN,GAAcA,KAAd;AACA,QAAI0D,KAAK,GAAGnD,OAAO,CAACC,IAAD,CAAP,IAAiBE,KAAK,CAACF,IAAD,CAAtB,IAAgCwE,OAAO,CAACxE,IAAD,CAAnD;AACA,QAAIyG,GAAG,GAAGH,MAAM,IAAIA,MAAM,CAACtG,IAAD,CAAN,IAAgB,IAA1B,GAAiCsG,MAAM,CAACtG,IAAD,CAAvC,GAAgD,MAAMkD,KAAhE;AACA,QAAIuD,GAAG,KAAK,EAAZ,EAAgB,OAAOA,GAAP;AAEhB,QAAIC,GAAG,GAAG,MAAM,KAAKP,OAAL,CAAaM,GAAb,EAAkBvG,KAAlB,EAAyBoG,MAAzB,EAAiCC,CAAjC,CAAhB;;AACA,QAAI,CAACG,GAAD,IAAQJ,MAAR,IAAkBA,MAAM,CAACtG,IAAD,CAA5B,EAAoC;AAClC,aAAO,KAAKmG,OAAL,CAAajD,KAAb,EAAoBhD,KAApB,EAA2BoG,MAA3B,EAAmCC,CAAnC,CAAP;AACD;;AACD,WAAOG,GAAP;AACD;;AAEW,QAANC,MAAM,GAAG;AACb,QAAIN,OAAO,GAAG,OAAM,KAAKA,OAAL,CAAa,QAAb,CAAN,KAAgC,KAAK7B,OAAnD;AACA,QAAIhF,KAAK,GAAG,KAAKgH,MAAL,IAAe,KAAKA,MAAL,CAAYG,MAAvC;AACA,QAAIzG,KAAK,GAAG,KAAKA,KAAjB;AACAA,IAAAA,KAAK,CAACV,KAAN,GAAcA,KAAd;AACA,QAAIG,KAAK,CAACiH,QAAN,CAAeP,OAAf,CAAJ,EAA6BA,OAAO,GAAGA,OAAO,CAACnG,KAAK,CAAC2G,MAAP,CAAP,IAAyBR,OAAO,CAACS,OAA3C;;AAC7B,QAAI,CAACnH,KAAK,CAACoH,QAAN,CAAeV,OAAf,CAAL,EAA8B;AAC5B,UAAIW,KAAK,GAAG,KAAKrC,MAAL,CAAYzE,KAAK,CAAC2G,MAAlB,KAA6B,KAAKlC,MAAL,CAAYmC,OAArD;AACA,aAAOE,KAAK,CAACX,OAAD,CAAZ;AACD;;AACD,WAAOA,OAAP;AACD;;AAEY,QAAPY,OAAO,GAAG;AACd,QAAIA,OAAO,GAAG,MAAM,KAAKZ,OAAL,CAAa,SAAb,CAApB;;AACA,QAAI,CAAC1G,KAAK,CAACoH,QAAN,CAAeE,OAAf,CAAL,EAA8B;AAC5B,aAAO,KAAKtC,MAAL,CAAYuC,MAAZ,CAAmBD,OAAnB,CAAP;AACD;;AACD,WAAOA,OAAP;AACD;;AAEc,QAATE,SAAS,GAAG;AAChB,QAAId,OAAO,GAAG,OAAM,KAAKA,OAAL,CAAa,WAAb,CAAN,KAAmC,KAAK7B,OAAtD;AACA,QAAIhF,KAAK,GAAG,KAAKgH,MAAL,IAAe,KAAKA,MAAL,CAAYW,SAAvC;AACA,QAAIjH,KAAK,GAAG,KAAKA,KAAjB;AACAA,IAAAA,KAAK,CAACV,KAAN,GAAcA,KAAd;AACA,QAAI0D,KAAK,GAAGmD,OAAO,CAACnG,KAAK,CAAC2G,MAAP,CAAP,IAAyBR,OAAO,CAACS,OAAjC,IAA4C5G,KAAK,CAACiH,SAA9D;AACA,QAAIC,GAAG,GAAG,MAAM,KAAKjB,OAAL,CAAajD,KAAb,EAAoBhD,KAApB,CAAhB;AACA,QAAIP,KAAK,CAACiH,QAAN,CAAeQ,GAAf,CAAJ,EAAyBA,GAAG,GAAGA,GAAG,CAAClH,KAAK,CAAC2G,MAAP,CAAH,IAAqBO,GAAG,CAACN,OAA/B;;AACzB,QAAI,CAACnH,KAAK,CAACoH,QAAN,CAAeK,GAAf,CAAL,EAA0B;AACxB,aAAO,KAAKzC,MAAL,CAAY0C,KAAZ,CAAkBD,GAAlB,CAAP;AACD;;AACD,WAAOA,GAAP;AACD;;AAEY,QAAP3C,OAAO,CAAC6B,MAAD,EAASC,CAAT,EAAY;AACvB,QAAIE,GAAG,GAAG,MAAM,KAAKJ,OAAL,CAAa,SAAb,EAAwBC,MAAxB,EAAgCC,CAAhC,CAAhB;;AAEA,QAAI,OAAOE,GAAP,KAAe,QAAf,IAA2B9G,KAAK,CAACoH,QAAN,CAAeN,GAAf,CAA/B,EAAoD;AAClD,aAAOA,GAAP;AACD;;AAED,QAAIA,GAAJ,EAAS;AACP,UAAI9B,MAAM,GAAG,KAAKA,MAAlB;AACA,UAAI2C,OAAO,GAAG,KAAKC,KAAL,KAAehB,CAA7B;AACA,UAAIS,KAAK,GAAGM,OAAO,GAAG3C,MAAM,CAAC6C,OAAV,GAAoBf,GAAG,IAAIA,GAA9C;AACA,UAAIW,GAAG,GAAG,MAAM,KAAKjB,OAAL,CAAaM,GAAG,CAACa,OAAO,GAAG,IAAH,GAAU,KAAlB,CAAH,IAA+Bb,GAA5C,EAAiD,KAAKvG,KAAtD,CAAhB;AACA,UAAIuH,MAAM,GAAG,CAAC9H,KAAK,CAACoH,QAAN,CAAeK,GAAf,CAAD,GAAuBJ,KAAK,CAACI,GAAD,CAA5B,GAAoCA,GAAjD;AACA,aAAOE,OAAO,GAAGG,MAAH,GAAY,IAAIpC,MAAJ,CAAW+B,GAAG,CAAChE,MAAf,CAA1B;AACD;AACF;;AAEc,QAATsE,SAAS,CAACpB,MAAD,EAASC,CAAT,EAAY;AACzB,QAAIE,GAAG,GAAG,MAAM,KAAKJ,OAAL,CAAa,WAAb,EAA0BC,MAA1B,EAAkCC,CAAlC,CAAhB;;AACA,QAAI,OAAOE,GAAP,KAAe,QAAf,IAA2B9G,KAAK,CAACoH,QAAN,CAAeN,GAAf,CAA/B,EAAoD;AAClD,aAAOA,GAAP;AACD;;AACD,QAAIA,GAAJ,EAAS;AACP,UAAI9B,MAAM,GAAG,KAAKA,MAAlB;AACA,UAAIgD,OAAO,GAAGrB,MAAM,CAACqB,OAAP,KAAmB,IAAjC;AACA,UAAIX,KAAK,GAAGW,OAAO,GAAGhD,MAAM,CAACiD,OAAV,GAAoBjD,MAAM,CAACkD,IAA9C;AACA,UAAIT,GAAG,GAAGX,GAAG,CAACkB,OAAO,GAAG,IAAH,GAAU,KAAlB,CAAH,IAA+BlB,GAAzC;AACA,aAAO,CAAC9G,KAAK,CAACoH,QAAN,CAAeK,GAAf,CAAD,GAAuBJ,KAAK,CAACI,GAAD,CAA5B,GAAoCA,GAA3C;AACD;;AACD,WAAO,EAAP;AACD;;AAEDU,EAAAA,IAAI,GAAG;AACL,WAAO,IAAP;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACP,QAAI,KAAK7H,KAAL,CAAW2G,MAAX,KAAsB,SAA1B,EAAqC;AACnC,aAAO,KAAKR,OAAL,CAAa,QAAb,CAAP;AACD;AACF;;AAED3C,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKxD,KAAL,CAAW2G,MAAX,KAAsB,SAA1B,EAAqC;AACnC,aAAO,KAAKR,OAAL,CAAa,QAAb,CAAP;AACD;AACF;;AAES,QAAJ2B,IAAI,GAAG;AACX,QAAI,KAAK9H,KAAL,CAAW2G,MAAX,KAAsB,SAAtB,IAAmC,CAAC,KAAKoB,OAAL,CAAa,KAAK/H,KAAL,CAAWe,KAAxB,CAAxC,EAAwE;AACtE,UAAI+G,IAAI,GAAG,MAAM,KAAK3B,OAAL,CAAa,MAAb,CAAjB;;AACA,UAAI,CAAC1G,KAAK,CAACoH,QAAN,CAAeiB,IAAf,CAAL,EAA2B;AACzB,eAAO,KAAKrD,MAAL,CAAY0C,KAAZ,CAAkBW,IAAlB,CAAP;AACD;;AACD,aAAOA,IAAP;AACD;AACF;;AAED1D,EAAAA,KAAK,CAACU,GAAD,EAAM;AACT,WAAO,CAAC,KAAK9E,KAAL,CAAWgE,SAAZ,GAAyBc,GAAG,IAAI,KAAK9E,KAAL,CAAWoE,KAA3C,GAAoD,EAA3D;AACD;;AAEDwB,EAAAA,MAAM,CAAC5C,KAAD,EAAQ;AACZ,WAAOA,KAAP;AACD;;AAEDmB,EAAAA,MAAM,CAACnB,KAAD,EAAQ;AACZ,WAAOA,KAAP;AACD;;AAEDqB,EAAAA,QAAQ,CAACrB,KAAD,EAAQ;AACd,QAAI,KAAKnD,OAAL,CAAamI,QAAb,KAA0B,IAA9B,EAAoC;AAClC,aAAO,KAAKD,OAAL,CAAa/E,KAAb,CAAP;AACD;;AACD,WAAO,IAAP;AACD;;AAED+E,EAAAA,OAAO,CAAC/E,KAAD,EAAQ;AACb,WAAOA,KAAK,IAAI,IAAT,IAAiBA,KAAK,KAAK,EAAlC;AACD;;AAEDiD,EAAAA,OAAO,CAACjD,KAAD,EAAQ,GAAGiF,IAAX,EAAiB;AACtB,WAAOxI,KAAK,CAACwG,OAAN,CAAc,IAAd,EAAoBjD,KAApB,EAA2B,GAAGiF,IAA9B,CAAP;AACD;;AAEO,MAAJC,IAAI,GAAG;AACT,WAAOvI,MAAM,CAACwI,SAAd;AACD;;AAEQ,MAALrB,KAAK,GAAG;AACV,WAAO,KAAKrC,MAAL,CAAY,KAAKzE,KAAL,CAAW2G,MAAvB,CAAP;AACD;;AAES,MAANyB,MAAM,GAAG;AACX,WAAO,KAAKvI,OAAL,CAAawI,IAAb,IAAqB5I,KAAK,CAAC2I,MAAN,CAAa,KAAK/H,MAAlB,EAA0B,EAA1B,CAA5B;AACD;;AACQ,MAALoC,KAAK,GAAG;AACV,WAAO,KAAK5C,OAAL,CAAayI,OAAb,IAAwB7I,KAAK,CAACgD,KAAN,CAAY,KAAKpC,MAAjB,EAAyB,EAAzB,CAA/B;AACD;;AACO,MAAJ4C,IAAI,GAAG;AACT,WAAO;AAAER,MAAAA,KAAK,EAAE,KAAKA,KAAd;AAAqB2F,MAAAA,MAAM,EAAE,KAAKA;AAAlC,KAAP;AACD;;AAES,MAANpG,MAAM,CAACgB,KAAD,EAAQ;AAChB,SAAKhD,KAAL,CAAWgC,MAAX,GAAoBgB,KAApB;AACD;;AACS,MAANhB,MAAM,GAAG;AACX,WAAO,KAAKhC,KAAL,CAAWgC,MAAlB;AACD;;AAEQ,MAALjB,KAAK,CAACiC,KAAD,EAAQ;AACf,SAAKhD,KAAL,CAAWe,KAAX,GAAmBiC,KAAnB;AACD;;AACQ,MAALjC,KAAK,GAAG;AACV,WAAO,KAAKf,KAAL,CAAWe,KAAlB;AACD;;AAEQ,MAALiC,KAAK,CAACA,KAAD,EAAQ;AACf,SAAKhD,KAAL,CAAWgD,KAAX,GAAmBA,KAAnB;AACD;;AACQ,MAALA,KAAK,GAAG;AACV,QAAI;AAAEjC,MAAAA,KAAF;AAASiC,MAAAA;AAAT,QAAmB,KAAKhD,KAA5B;AACA,QAAImE,MAAM,GAAG,CAACnB,KAAD,EAAQjC,KAAR,EAAeZ,IAAf,CAAoB,KAAK4H,OAAL,CAAaxC,IAAb,CAAkB,IAAlB,CAApB,CAAb;AACA,WAAO,KAAKwC,OAAL,CAAa5D,MAAb,IAAuBA,MAAvB,GAAgC,KAAKlE,OAA5C;AACD;;AAEgB,aAAN2C,MAAM,GAAG;AAClB,WAAO/C,OAAO,IAAI,IAAI,IAAJ,CAASA,OAAT,EAAkBkG,GAAlB,EAAlB;AACD;;AAlZyB;;AAqZ5B,SAASjF,UAAT,CAAoB8B,MAApB,EAA4B;AAC1B,MAAI2F,UAAU,GAAGrH,GAAG,IAAI;AACtB,WAAO0B,MAAM,CAAC1B,GAAD,CAAN,KAAgB,KAAK,CAArB,IAA0B,OAAO0B,MAAM,CAAC1B,GAAD,CAAb,KAAuB,UAAxD;AACD,GAFD;;AAIA,MAAIsH,MAAM,GAAG,CACX,SADW,EAEX,SAFW,EAGX,SAHW,EAIX,QAJW,EAKX,OALW,EAMX,QANW,EAOX,SAPW,EAQX,OARW,EASX,QATW,EAUX,OAVW,CAAb;AAaA,MAAIC,QAAQ,GAAG,CACb,MADa,EAEb,QAFa,EAGb,OAHa,EAIb,QAJa,EAKb,MALa,EAMb,WANa,EAOb,SAPa,EAQb,QARa,EASb,WATa,EAUb,MAVa,CAAf;;AAaA,OAAK,IAAIvH,GAAT,IAAgBwH,MAAM,CAACC,IAAP,CAAY/F,MAAM,CAAC/C,OAAnB,CAAhB,EAA6C;AAC3C,QAAI2I,MAAM,CAACI,QAAP,CAAgB1H,GAAhB,CAAJ,EAA0B;AAC1B,QAAI,WAAW2H,IAAX,CAAgB3H,GAAhB,CAAJ,EAA0B;AAC1B,QAAI4H,MAAM,GAAGlG,MAAM,CAAC/C,OAAP,CAAeqB,GAAf,CAAb;;AACA,QAAI,OAAO4H,MAAP,KAAkB,UAAlB,IAAgCP,UAAU,CAACrH,GAAD,CAA9C,EAAqD;AACnD,UAAI,CAACuH,QAAQ,CAACG,QAAT,CAAkB1H,GAAlB,CAAL,EAA6B;AAC3B0B,QAAAA,MAAM,CAAC1B,GAAD,CAAN,GAAc4H,MAAM,CAACvD,IAAP,CAAY3C,MAAZ,CAAd;AACD;AACF,KAJD,MAIO,IAAI,OAAOA,MAAM,CAAC1B,GAAD,CAAb,KAAuB,UAA3B,EAAuC;AAC5C0B,MAAAA,MAAM,CAAC1B,GAAD,CAAN,GAAc4H,MAAd;AACD;AACF;AACF;;AAED,SAASlI,MAAT,CAAgBoC,KAAhB,EAAuB;AACrB,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,IAAAA,KAAK,GAAG,CAACA,KAAD,EAAQA,KAAR,EAAeA,KAAf,EAAsBA,KAAtB,CAAR;AACD;;AACD,MAAI+F,GAAG,GAAG,GAAGC,MAAH,CAAUhG,KAAK,IAAI,EAAnB,CAAV;;AACA,MAAIiG,GAAG,GAAG5C,CAAC,IAAIA,CAAC,GAAG,CAAJ,KAAU,CAAV,GAAc,IAAd,GAAqB,GAApC;;AACA,MAAIG,GAAG,GAAG,EAAV;;AACA,OAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,QAAI6C,IAAI,GAAGD,GAAG,CAAC5C,CAAD,CAAd;;AACA,QAAI0C,GAAG,CAAC1C,CAAD,CAAP,EAAY;AACVG,MAAAA,GAAG,CAAC2C,IAAJ,CAASD,IAAI,CAAC/D,MAAL,CAAY4D,GAAG,CAAC1C,CAAD,CAAf,CAAT;AACD,KAFD,MAEO;AACLG,MAAAA,GAAG,CAAC2C,IAAJ,CAAS,EAAT;AACD;AACF;;AACD,SAAO3C,GAAP;AACD;;AAED4C,MAAM,CAACC,OAAP,GAAiB1J,MAAjB","sourcesContent":["'use strict';\n\nconst Events = require('events');\nconst colors = require('ansi-colors');\nconst keypress = require('./keypress');\nconst timer = require('./timer');\nconst State = require('./state');\nconst theme = require('./theme');\nconst utils = require('./utils');\nconst ansi = require('./ansi');\n\n/**\n * Base class for creating a new Prompt.\n * @param {Object} `options` Question object.\n */\n\nclass Prompt extends Events {\n  constructor(options = {}) {\n    super();\n    this.name = options.name;\n    this.type = options.type;\n    this.options = options;\n    theme(this);\n    timer(this);\n    this.state = new State(this);\n    this.initial = [options.initial, options.default].find(v => v != null);\n    this.stdout = options.stdout || process.stdout;\n    this.stdin = options.stdin || process.stdin;\n    this.scale = options.scale || 1;\n    this.term = this.options.term || process.env.TERM_PROGRAM;\n    this.margin = margin(this.options.margin);\n    this.setMaxListeners(0);\n    setOptions(this);\n  }\n\n  async keypress(input, event = {}) {\n    this.keypressed = true;\n    let key = keypress.action(input, keypress(input, event), this.options.actions);\n    this.state.keypress = key;\n    this.emit('keypress', input, key);\n    this.emit('state', this.state.clone());\n    let fn = this.options[key.action] || this[key.action] || this.dispatch;\n    if (typeof fn === 'function') {\n      return await fn.call(this, input, key);\n    }\n    this.alert();\n  }\n\n  alert() {\n    delete this.state.alert;\n    if (this.options.show === false) {\n      this.emit('alert');\n    } else {\n      this.stdout.write(ansi.code.beep);\n    }\n  }\n\n  cursorHide() {\n    this.stdout.write(ansi.cursor.hide());\n    utils.onExit(() => this.cursorShow());\n  }\n\n  cursorShow() {\n    this.stdout.write(ansi.cursor.show());\n  }\n\n  write(str) {\n    if (!str) return;\n    if (this.stdout && this.state.show !== false) {\n      this.stdout.write(str);\n    }\n    this.state.buffer += str;\n  }\n\n  clear(lines = 0) {\n    let buffer = this.state.buffer;\n    this.state.buffer = '';\n    if ((!buffer && !lines) || this.options.show === false) return;\n    this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));\n  }\n\n  restore() {\n    if (this.state.closed || this.options.show === false) return;\n\n    let { prompt, after, rest } = this.sections();\n    let { cursor, initial = '', input = '', value = '' } = this;\n\n    let size = this.state.size = rest.length;\n    let state = { after, cursor, initial, input, prompt, size, value };\n    let codes = ansi.cursor.restore(state);\n    if (codes) {\n      this.stdout.write(codes);\n    }\n  }\n\n  sections() {\n    let { buffer, input, prompt } = this.state;\n    prompt = colors.unstyle(prompt);\n    let buf = colors.unstyle(buffer);\n    let idx = buf.indexOf(prompt);\n    let header = buf.slice(0, idx);\n    let rest = buf.slice(idx);\n    let lines = rest.split('\\n');\n    let first = lines[0];\n    let last = lines[lines.length - 1];\n    let promptLine = prompt + (input ? ' ' + input : '');\n    let len = promptLine.length;\n    let after = len < first.length ? first.slice(len + 1) : '';\n    return { header, prompt: first, after, rest: lines.slice(1), last };\n  }\n\n  async submit() {\n    this.state.submitted = true;\n    this.state.validating = true;\n\n    // this will only be called when the prompt is directly submitted\n    // without initializing, i.e. when the prompt is skipped, etc. Otherwize,\n    // \"options.onSubmit\" is will be handled by the \"initialize()\" method.\n    if (this.options.onSubmit) {\n      await this.options.onSubmit.call(this, this.name, this.value, this);\n    }\n\n    let result = this.state.error || await this.validate(this.value, this.state);\n    if (result !== true) {\n      let error = '\\n' + this.symbols.pointer + ' ';\n\n      if (typeof result === 'string') {\n        error += result.trim();\n      } else {\n        error += 'Invalid input';\n      }\n\n      this.state.error = '\\n' + this.styles.danger(error);\n      this.state.submitted = false;\n      await this.render();\n      await this.alert();\n      this.state.validating = false;\n      this.state.error = void 0;\n      return;\n    }\n\n    this.state.validating = false;\n    await this.render();\n    await this.close();\n\n    this.value = await this.result(this.value);\n    this.emit('submit', this.value);\n  }\n\n  async cancel(err) {\n    this.state.cancelled = this.state.submitted = true;\n\n    await this.render();\n    await this.close();\n\n    if (typeof this.options.onCancel === 'function') {\n      await this.options.onCancel.call(this, this.name, this.value, this);\n    }\n\n    this.emit('cancel', await this.error(err));\n  }\n\n  async close() {\n    this.state.closed = true;\n\n    try {\n      let sections = this.sections();\n      let lines = Math.ceil(sections.prompt.length / this.width);\n      if (sections.rest) {\n        this.write(ansi.cursor.down(sections.rest.length));\n      }\n      this.write('\\n'.repeat(lines));\n    } catch (err) { /* do nothing */ }\n\n    this.emit('close');\n  }\n\n  start() {\n    if (!this.stop && this.options.show !== false) {\n      this.stop = keypress.listen(this, this.keypress.bind(this));\n      this.once('close', this.stop);\n    }\n  }\n\n  async skip() {\n    this.skipped = this.options.skip === true;\n    if (typeof this.options.skip === 'function') {\n      this.skipped = await this.options.skip.call(this, this.name, this.value);\n    }\n    return this.skipped;\n  }\n\n  async initialize() {\n    let { format, options, result } = this;\n\n    this.format = () => format.call(this, this.value);\n    this.result = () => result.call(this, this.value);\n\n    if (typeof options.initial === 'function') {\n      this.initial = await options.initial.call(this, this);\n    }\n\n    if (typeof options.onRun === 'function') {\n      await options.onRun.call(this, this);\n    }\n\n    // if \"options.onSubmit\" is defined, we wrap the \"submit\" method to guarantee\n    // that \"onSubmit\" will always called first thing inside the submit\n    // method, regardless of how it's handled in inheriting prompts.\n    if (typeof options.onSubmit === 'function') {\n      let onSubmit = options.onSubmit.bind(this);\n      let submit = this.submit.bind(this);\n      delete this.options.onSubmit;\n      this.submit = async() => {\n        await onSubmit(this.name, this.value, this);\n        return submit();\n      };\n    }\n\n    await this.start();\n    await this.render();\n  }\n\n  render() {\n    throw new Error('expected prompt to have a custom render method');\n  }\n\n  run() {\n    return new Promise(async(resolve, reject) => {\n      this.once('submit', resolve);\n      this.once('cancel', reject);\n      if (await this.skip()) {\n        this.render = () => {};\n        return this.submit();\n      }\n      await this.initialize();\n      this.emit('run');\n    });\n  }\n\n  async element(name, choice, i) {\n    let { options, state, symbols, timers } = this;\n    let timer = timers && timers[name];\n    state.timer = timer;\n    let value = options[name] || state[name] || symbols[name];\n    let val = choice && choice[name] != null ? choice[name] : await value;\n    if (val === '') return val;\n\n    let res = await this.resolve(val, state, choice, i);\n    if (!res && choice && choice[name]) {\n      return this.resolve(value, state, choice, i);\n    }\n    return res;\n  }\n\n  async prefix() {\n    let element = await this.element('prefix') || this.symbols;\n    let timer = this.timers && this.timers.prefix;\n    let state = this.state;\n    state.timer = timer;\n    if (utils.isObject(element)) element = element[state.status] || element.pending;\n    if (!utils.hasColor(element)) {\n      let style = this.styles[state.status] || this.styles.pending;\n      return style(element);\n    }\n    return element;\n  }\n\n  async message() {\n    let message = await this.element('message');\n    if (!utils.hasColor(message)) {\n      return this.styles.strong(message);\n    }\n    return message;\n  }\n\n  async separator() {\n    let element = await this.element('separator') || this.symbols;\n    let timer = this.timers && this.timers.separator;\n    let state = this.state;\n    state.timer = timer;\n    let value = element[state.status] || element.pending || state.separator;\n    let ele = await this.resolve(value, state);\n    if (utils.isObject(ele)) ele = ele[state.status] || ele.pending;\n    if (!utils.hasColor(ele)) {\n      return this.styles.muted(ele);\n    }\n    return ele;\n  }\n\n  async pointer(choice, i) {\n    let val = await this.element('pointer', choice, i);\n\n    if (typeof val === 'string' && utils.hasColor(val)) {\n      return val;\n    }\n\n    if (val) {\n      let styles = this.styles;\n      let focused = this.index === i;\n      let style = focused ? styles.primary : val => val;\n      let ele = await this.resolve(val[focused ? 'on' : 'off'] || val, this.state);\n      let styled = !utils.hasColor(ele) ? style(ele) : ele;\n      return focused ? styled : ' '.repeat(ele.length);\n    }\n  }\n\n  async indicator(choice, i) {\n    let val = await this.element('indicator', choice, i);\n    if (typeof val === 'string' && utils.hasColor(val)) {\n      return val;\n    }\n    if (val) {\n      let styles = this.styles;\n      let enabled = choice.enabled === true;\n      let style = enabled ? styles.success : styles.dark;\n      let ele = val[enabled ? 'on' : 'off'] || val;\n      return !utils.hasColor(ele) ? style(ele) : ele;\n    }\n    return '';\n  }\n\n  body() {\n    return null;\n  }\n\n  footer() {\n    if (this.state.status === 'pending') {\n      return this.element('footer');\n    }\n  }\n\n  header() {\n    if (this.state.status === 'pending') {\n      return this.element('header');\n    }\n  }\n\n  async hint() {\n    if (this.state.status === 'pending' && !this.isValue(this.state.input)) {\n      let hint = await this.element('hint');\n      if (!utils.hasColor(hint)) {\n        return this.styles.muted(hint);\n      }\n      return hint;\n    }\n  }\n\n  error(err) {\n    return !this.state.submitted ? (err || this.state.error) : '';\n  }\n\n  format(value) {\n    return value;\n  }\n\n  result(value) {\n    return value;\n  }\n\n  validate(value) {\n    if (this.options.required === true) {\n      return this.isValue(value);\n    }\n    return true;\n  }\n\n  isValue(value) {\n    return value != null && value !== '';\n  }\n\n  resolve(value, ...args) {\n    return utils.resolve(this, value, ...args);\n  }\n\n  get base() {\n    return Prompt.prototype;\n  }\n\n  get style() {\n    return this.styles[this.state.status];\n  }\n\n  get height() {\n    return this.options.rows || utils.height(this.stdout, 25);\n  }\n  get width() {\n    return this.options.columns || utils.width(this.stdout, 80);\n  }\n  get size() {\n    return { width: this.width, height: this.height };\n  }\n\n  set cursor(value) {\n    this.state.cursor = value;\n  }\n  get cursor() {\n    return this.state.cursor;\n  }\n\n  set input(value) {\n    this.state.input = value;\n  }\n  get input() {\n    return this.state.input;\n  }\n\n  set value(value) {\n    this.state.value = value;\n  }\n  get value() {\n    let { input, value } = this.state;\n    let result = [value, input].find(this.isValue.bind(this));\n    return this.isValue(result) ? result : this.initial;\n  }\n\n  static get prompt() {\n    return options => new this(options).run();\n  }\n}\n\nfunction setOptions(prompt) {\n  let isValidKey = key => {\n    return prompt[key] === void 0 || typeof prompt[key] === 'function';\n  };\n\n  let ignore = [\n    'actions',\n    'choices',\n    'initial',\n    'margin',\n    'roles',\n    'styles',\n    'symbols',\n    'theme',\n    'timers',\n    'value'\n  ];\n\n  let ignoreFn = [\n    'body',\n    'footer',\n    'error',\n    'header',\n    'hint',\n    'indicator',\n    'message',\n    'prefix',\n    'separator',\n    'skip'\n  ];\n\n  for (let key of Object.keys(prompt.options)) {\n    if (ignore.includes(key)) continue;\n    if (/^on[A-Z]/.test(key)) continue;\n    let option = prompt.options[key];\n    if (typeof option === 'function' && isValidKey(key)) {\n      if (!ignoreFn.includes(key)) {\n        prompt[key] = option.bind(prompt);\n      }\n    } else if (typeof prompt[key] !== 'function') {\n      prompt[key] = option;\n    }\n  }\n}\n\nfunction margin(value) {\n  if (typeof value === 'number') {\n    value = [value, value, value, value];\n  }\n  let arr = [].concat(value || []);\n  let pad = i => i % 2 === 0 ? '\\n' : ' ';\n  let res = [];\n  for (let i = 0; i < 4; i++) {\n    let char = pad(i);\n    if (arr[i]) {\n      res.push(char.repeat(arr[i]));\n    } else {\n      res.push('');\n    }\n  }\n  return res;\n}\n\nmodule.exports = Prompt;\n"]},"metadata":{},"sourceType":"script"}