{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar debug = require('debug');\n/**\n * Expose `Server`.\n */\n\n\nmodule.exports = Server;\n/**\n * Initialize a server with the given `sock`.\n *\n * @param {Socket} sock\n * @api public\n */\n\nfunction Server(sock) {\n  if (typeof sock.format === 'function') sock.format('json');\n  this.sock = sock;\n  this.methods = {};\n  this.sock.on('message', this.onmessage.bind(this));\n}\n/**\n * Return method descriptions with:\n *\n *  `.name` string\n *  `.params` array\n *\n * @return {Object}\n * @api private\n */\n\n\nServer.prototype.methodDescriptions = function () {\n  var obj = {};\n  var fn;\n\n  for (var name in this.methods) {\n    fn = this.methods[name];\n    obj[name] = {\n      name: name,\n      params: params(fn)\n    };\n  }\n\n  return obj;\n};\n/**\n * Response with the method descriptions.\n *\n * @param {Function} fn\n * @api private\n */\n\n\nServer.prototype.respondWithMethods = function (reply) {\n  reply({\n    methods: this.methodDescriptions()\n  });\n};\n/**\n * Handle `msg`.\n *\n * @param {Object} msg\n * @param {Object} fn\n * @api private\n */\n\n\nServer.prototype.onmessage = function (msg, reply) {\n  if ('methods' == msg.type) return this.respondWithMethods(reply);\n\n  if (!reply) {\n    console.error('reply false');\n    return false;\n  } // .method\n\n\n  var meth = msg.method;\n  if (!meth) return reply({\n    error: '.method required'\n  }); // ensure .method is exposed\n\n  var fn = this.methods[meth];\n  if (!fn) return reply({\n    error: 'method \"' + meth + '\" does not exist'\n  }); // .args\n\n  var args = msg.args;\n  if (!args) return reply({\n    error: '.args required'\n  }); // invoke\n\n  args.push(function (err) {\n    if (err) {\n      if (err instanceof Error) return reply({\n        error: err.message,\n        stack: err.stack\n      });else return reply({\n        error: err\n      });\n    }\n\n    var args = [].slice.call(arguments, 1);\n    reply({\n      args: args\n    });\n  });\n  fn.apply(null, args);\n};\n/**\n * Expose many or a single method.\n *\n * @param {String|Object} name\n * @param {String|Object} fn\n * @api public\n */\n\n\nServer.prototype.expose = function (name, fn) {\n  if (1 == arguments.length) {\n    for (var key in name) {\n      this.expose(key, name[key]);\n    }\n  } else {\n    debug('expose \"%s\"', name);\n    this.methods[name] = fn;\n  }\n};\n/**\n * Parse params.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\n\nfunction params(fn) {\n  // remove space to make it work on node 10.x.x too\n  var ret = fn.toString().replace(/\\s/g, '').match(/^function *(\\w*)\\((.*?)\\)/)[2];\n  if (ret) return ret.split(/ *, */);\n  return [];\n}","map":{"version":3,"sources":["/Users/samianki/node_modules/@pm2/agent/node_modules/pm2-axon-rpc/lib/server.js"],"names":["debug","require","module","exports","Server","sock","format","methods","on","onmessage","bind","prototype","methodDescriptions","obj","fn","name","params","respondWithMethods","reply","msg","type","console","error","meth","method","args","push","err","Error","message","stack","slice","call","arguments","apply","expose","length","key","ret","toString","replace","match","split"],"mappings":"AACA;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;AAEA;AACA;AACA;;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,MAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,MAAT,CAAgBC,IAAhB,EAAsB;AACpB,MAAI,OAAOA,IAAI,CAACC,MAAZ,KAAuB,UAA3B,EAAuCD,IAAI,CAACC,MAAL,CAAY,MAAZ;AACvC,OAAKD,IAAL,GAAYA,IAAZ;AACA,OAAKE,OAAL,GAAe,EAAf;AACA,OAAKF,IAAL,CAAUG,EAAV,CAAa,SAAb,EAAwB,KAAKC,SAAL,CAAeC,IAAf,CAAoB,IAApB,CAAxB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAN,MAAM,CAACO,SAAP,CAAiBC,kBAAjB,GAAsC,YAAU;AAC9C,MAAIC,GAAG,GAAG,EAAV;AACA,MAAIC,EAAJ;;AAEA,OAAK,IAAIC,IAAT,IAAiB,KAAKR,OAAtB,EAA+B;AAC7BO,IAAAA,EAAE,GAAG,KAAKP,OAAL,CAAaQ,IAAb,CAAL;AACAF,IAAAA,GAAG,CAACE,IAAD,CAAH,GAAY;AACVA,MAAAA,IAAI,EAAEA,IADI;AAEVC,MAAAA,MAAM,EAAEA,MAAM,CAACF,EAAD;AAFJ,KAAZ;AAID;;AAED,SAAOD,GAAP;AACD,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;;;AAEAT,MAAM,CAACO,SAAP,CAAiBM,kBAAjB,GAAsC,UAASC,KAAT,EAAe;AACnDA,EAAAA,KAAK,CAAC;AAAEX,IAAAA,OAAO,EAAE,KAAKK,kBAAL;AAAX,GAAD,CAAL;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAR,MAAM,CAACO,SAAP,CAAiBF,SAAjB,GAA6B,UAASU,GAAT,EAAcD,KAAd,EAAoB;AAC/C,MAAI,aAAaC,GAAG,CAACC,IAArB,EAA2B,OAAO,KAAKH,kBAAL,CAAwBC,KAAxB,CAAP;;AAE3B,MAAI,CAACA,KAAL,EAAY;AACVG,IAAAA,OAAO,CAACC,KAAR,CAAc,aAAd;AACA,WAAO,KAAP;AACD,GAN8C,CAQ/C;;;AACA,MAAIC,IAAI,GAAGJ,GAAG,CAACK,MAAf;AACA,MAAI,CAACD,IAAL,EAAW,OAAOL,KAAK,CAAC;AAAEI,IAAAA,KAAK,EAAE;AAAT,GAAD,CAAZ,CAVoC,CAY/C;;AACA,MAAIR,EAAE,GAAG,KAAKP,OAAL,CAAagB,IAAb,CAAT;AACA,MAAI,CAACT,EAAL,EAAS,OAAOI,KAAK,CAAC;AAAEI,IAAAA,KAAK,EAAE,aAAaC,IAAb,GAAoB;AAA7B,GAAD,CAAZ,CAdsC,CAgB/C;;AACA,MAAIE,IAAI,GAAGN,GAAG,CAACM,IAAf;AACA,MAAI,CAACA,IAAL,EAAW,OAAOP,KAAK,CAAC;AAAEI,IAAAA,KAAK,EAAE;AAAT,GAAD,CAAZ,CAlBoC,CAoB/C;;AACAG,EAAAA,IAAI,CAACC,IAAL,CAAU,UAASC,GAAT,EAAa;AACrB,QAAIA,GAAJ,EAAS;AACP,UAAIA,GAAG,YAAYC,KAAnB,EACE,OAAOV,KAAK,CAAC;AAAEI,QAAAA,KAAK,EAAEK,GAAG,CAACE,OAAb;AAAsBC,QAAAA,KAAK,EAAEH,GAAG,CAACG;AAAjC,OAAD,CAAZ,CADF,KAGE,OAAOZ,KAAK,CAAC;AAACI,QAAAA,KAAK,EAAGK;AAAT,OAAD,CAAZ;AACH;;AACD,QAAIF,IAAI,GAAG,GAAGM,KAAH,CAASC,IAAT,CAAcC,SAAd,EAAyB,CAAzB,CAAX;AACAf,IAAAA,KAAK,CAAC;AAAEO,MAAAA,IAAI,EAAEA;AAAR,KAAD,CAAL;AACD,GATD;AAWAX,EAAAA,EAAE,CAACoB,KAAH,CAAS,IAAT,EAAeT,IAAf;AACD,CAjCD;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEArB,MAAM,CAACO,SAAP,CAAiBwB,MAAjB,GAA0B,UAASpB,IAAT,EAAeD,EAAf,EAAkB;AAC1C,MAAI,KAAKmB,SAAS,CAACG,MAAnB,EAA2B;AACzB,SAAK,IAAIC,GAAT,IAAgBtB,IAAhB,EAAsB;AACpB,WAAKoB,MAAL,CAAYE,GAAZ,EAAiBtB,IAAI,CAACsB,GAAD,CAArB;AACD;AACF,GAJD,MAIO;AACLrC,IAAAA,KAAK,CAAC,aAAD,EAAgBe,IAAhB,CAAL;AACA,SAAKR,OAAL,CAAaQ,IAAb,IAAqBD,EAArB;AACD;AACF,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASE,MAAT,CAAgBF,EAAhB,EAAoB;AAClB;AACA,MAAIwB,GAAG,GAAGxB,EAAE,CAACyB,QAAH,GAAcC,OAAd,CAAsB,KAAtB,EAA6B,EAA7B,EAAiCC,KAAjC,CAAuC,2BAAvC,EAAoE,CAApE,CAAV;AACA,MAAIH,GAAJ,EAAS,OAAOA,GAAG,CAACI,KAAJ,CAAU,OAAV,CAAP;AACT,SAAO,EAAP;AACD","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug');\n\n/**\n * Expose `Server`.\n */\n\nmodule.exports = Server;\n\n/**\n * Initialize a server with the given `sock`.\n *\n * @param {Socket} sock\n * @api public\n */\n\nfunction Server(sock) {\n  if (typeof sock.format === 'function') sock.format('json');\n  this.sock = sock;\n  this.methods = {};\n  this.sock.on('message', this.onmessage.bind(this));\n}\n\n/**\n * Return method descriptions with:\n *\n *  `.name` string\n *  `.params` array\n *\n * @return {Object}\n * @api private\n */\n\nServer.prototype.methodDescriptions = function(){\n  var obj = {};\n  var fn;\n\n  for (var name in this.methods) {\n    fn = this.methods[name];\n    obj[name] = {\n      name: name,\n      params: params(fn)\n    };\n  }\n\n  return obj;\n};\n\n/**\n * Response with the method descriptions.\n *\n * @param {Function} fn\n * @api private\n */\n\nServer.prototype.respondWithMethods = function(reply){\n  reply({ methods: this.methodDescriptions() });\n};\n\n/**\n * Handle `msg`.\n *\n * @param {Object} msg\n * @param {Object} fn\n * @api private\n */\n\nServer.prototype.onmessage = function(msg, reply){\n  if ('methods' == msg.type) return this.respondWithMethods(reply);\n\n  if (!reply) {\n    console.error('reply false');\n    return false;\n  }\n\n  // .method\n  var meth = msg.method;\n  if (!meth) return reply({ error: '.method required' });\n\n  // ensure .method is exposed\n  var fn = this.methods[meth];\n  if (!fn) return reply({ error: 'method \"' + meth + '\" does not exist' });\n\n  // .args\n  var args = msg.args;\n  if (!args) return reply({ error: '.args required' });\n\n  // invoke\n  args.push(function(err){\n    if (err) {\n      if (err instanceof Error)\n        return reply({ error: err.message, stack: err.stack });\n      else\n        return reply({error : err});\n    }\n    var args = [].slice.call(arguments, 1);\n    reply({ args: args });\n  });\n\n  fn.apply(null, args);\n};\n\n/**\n * Expose many or a single method.\n *\n * @param {String|Object} name\n * @param {String|Object} fn\n * @api public\n */\n\nServer.prototype.expose = function(name, fn){\n  if (1 == arguments.length) {\n    for (var key in name) {\n      this.expose(key, name[key]);\n    }\n  } else {\n    debug('expose \"%s\"', name);\n    this.methods[name] = fn;\n  }\n};\n\n/**\n * Parse params.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\nfunction params(fn) {\n  // remove space to make it work on node 10.x.x too\n  var ret = fn.toString().replace(/\\s/g, '').match(/^function *(\\w*)\\((.*?)\\)/)[2];\n  if (ret) return ret.split(/ *, */);\n  return [];\n}\n"]},"metadata":{},"sourceType":"script"}